#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
pub mod constants {
    use cosmwasm_std::Uint128;
    pub const MARKETPLACE_USDC_INDICATOR: &str = "TOTAL_USDC";
    pub const MIN_PRICE: Uint128 = Uint128::new(10_000u128);
    pub const MAX_PRICE: Uint128 = Uint128::new(1_000_000_000_000_000_000u128);
    pub const MAX_EXPIRATION_SECONDS: u64 = 31_536_000u64;
    pub const MIN_EXPIRATION_SECONDS: u64 = 86_400u64;
    pub const MAX_NFT_PER_COLLECTION: u32 = 10_000u32;
    pub const MADHUAHUA_NFTS: &str = "chihuahua1xv4zzcs3hqfwjfcpaq3swtj9unfa7qa4km00rxclwg98zuvw82tsnwxnw7";
    pub const SANCTUARY_NFTS: &str = "chihuahua1s6uhncxycfakk27ja765rmt05g5zzxjtw0kx3pad64077w0aar7qm64akt";
    pub const TEST_NFTS: &str = "contract6";
}
#[cfg(not(feature = "library"))]
pub mod contract {
    use cosmwasm_std::{Binary, StdResult, to_binary};
    use cosmwasm_std::{Deps, DepsMut, Env, MessageInfo, Response};
    #[cfg(not(feature = "library"))]
    use cosmwasm_std::entry_point;
    use cw2;
    use general_utils::error::ContractError;
    use general_utils::validations::{if_admin, if_enabled};
    use crate::execute_functions::{
        add_new_nft_collection, answer_offer, buy_nft, cancel_nft_sale, cancel_offer,
        claim_marketplace_fees, create_profile, instantiate, offer, receive_cw20,
        sell_nft, send_message, transfer_my_nft, update_config, update_nft_sale,
        update_profile,
    };
    use crate::msg::{ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg};
    use crate::state::CONFIG;
    const CONTRACT_NAME: &str = "crates.io:chihuahua_nft_marketplace";
    const CONTRACT_VERSION: &str = "0.0.1";
    pub fn instantiate(
        deps: DepsMut,
        _env: Env,
        info: MessageInfo,
        init_msg: InstantiateMsg,
    ) -> Result<Response, ContractError> {
        cw2::set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;
        instantiate::instantiate_contract(deps, info, init_msg)
    }
    pub fn execute(
        deps: DepsMut,
        env: Env,
        info: MessageInfo,
        msg: ExecuteMsg,
    ) -> Result<Response, ContractError> {
        let config = CONFIG.load(deps.storage)?;
        match msg {
            ExecuteMsg::UpdateConfig { list_of_updates } => {
                if_admin(&config.contract_owner, info.sender.as_ref())?;
                update_config::execute_update_config(deps, env, info, list_of_updates)
            }
            ExecuteMsg::ClaimMarketplaceFees {} => {
                if_admin(&config.contract_owner, info.sender.as_ref())?;
                claim_marketplace_fees::execute_claim_marketplace_fees(deps)
            }
            ExecuteMsg::AddNewCollection {
                nft_collection_address,
                nft_contract_type,
            } => {
                if_admin(&config.contract_owner, info.sender.as_ref())?;
                add_new_nft_collection::execute_add_new_nft_collection(
                    deps,
                    env,
                    info,
                    nft_collection_address,
                    nft_contract_type,
                )
            }
            ExecuteMsg::TransferMyNft {
                nft_collection_address,
                token_id,
                recipient,
            } => {
                if_enabled(config.contract_enabled)?;
                transfer_my_nft::execute_transfer_my_nft(
                    deps,
                    env,
                    info,
                    nft_collection_address,
                    token_id,
                    recipient,
                )
            }
            ExecuteMsg::SellNft { sale_info } => {
                if_enabled(config.contract_enabled)?;
                sell_nft::execute_sell_nft(deps, env, info, sale_info)
            }
            ExecuteMsg::UpdateSale { sale_info } => {
                if_enabled(config.contract_enabled)?;
                update_nft_sale::execute_update_nft_sale(deps, env, info, sale_info)
            }
            ExecuteMsg::CancelSale {
                nft_collection_address,
                token_id,
                additional_info,
            } => {
                if_enabled(config.contract_enabled)?;
                cancel_nft_sale::execute_cancel_nft_sale(
                    deps,
                    env,
                    info,
                    nft_collection_address,
                    token_id,
                    additional_info,
                )
            }
            ExecuteMsg::BuyNft { nft_collection_address, token_id, additional_info } => {
                if_enabled(config.contract_enabled)?;
                buy_nft::execute_buy_nft(
                    deps,
                    env,
                    info,
                    nft_collection_address,
                    token_id,
                    additional_info,
                )
            }
            ExecuteMsg::Offer { offer } => {
                if_enabled(config.contract_enabled)?;
                offer::execute_offer(deps, env, info, offer)
            }
            ExecuteMsg::CancelOffer {
                nft_collection_address,
                token_id,
                additional_info,
            } => {
                if_enabled(config.contract_enabled)?;
                cancel_offer::execute_cancel_offer(
                    deps,
                    env,
                    info,
                    nft_collection_address,
                    token_id,
                    additional_info,
                )
            }
            ExecuteMsg::AnswerOffer {
                nft_collection_address,
                token_id,
                from,
                if_accepted,
                answer_msg,
            } => {
                if_enabled(config.contract_enabled)?;
                answer_offer::execute_answer_offer(
                    deps,
                    env,
                    info,
                    nft_collection_address,
                    token_id,
                    from,
                    if_accepted,
                    answer_msg,
                )
            }
            ExecuteMsg::SendMessage { to, message } => {
                if_enabled(config.contract_enabled)?;
                send_message::execute_send_message(deps, env, info, to, message)
            }
            ExecuteMsg::CreateMyProfile { additional_info } => {
                if_enabled(config.contract_enabled)?;
                create_profile::execute_create_profile(deps, env, info, additional_info)
            }
            ExecuteMsg::UpdateMyProfile { profile, profile_update_action } => {
                if_enabled(config.contract_enabled)?;
                update_profile::execute_update_profile(
                    deps,
                    env,
                    info,
                    profile,
                    profile_update_action,
                )
            }
            ExecuteMsg::Receive(msg) => {
                if_enabled(config.contract_enabled)?;
                receive_cw20::execute_receive_cw20(deps, info, msg, env)
            }
        }
    }
    pub fn migrate(
        _deps: DepsMut,
        _env: Env,
        _msg: MigrateMsg,
    ) -> Result<Response, ContractError> {
        Ok(Response::default())
    }
    pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {
        match msg {
            QueryMsg::GetConfig {} => to_binary(&crate::query::query_config(deps)?),
            QueryMsg::GetNftCollectionInfo { nft_collection_address } => {
                to_binary(
                    &crate::query::query_nft_collection(deps, nft_collection_address)?,
                )
            }
            QueryMsg::GetMarketplaceVolume {} => {
                to_binary(&crate::query::query_marketplace_total_volume(deps)?)
            }
            QueryMsg::GetNftCollectionVolume { nft_collection_address } => {
                to_binary(
                    &crate::query::query_nft_collection_total_volume(
                        deps,
                        nft_collection_address,
                    )?,
                )
            }
            QueryMsg::GetNftCollectionType { nft_collection_address } => {
                to_binary(
                    &crate::query::query_nft_collection_type(
                        deps,
                        nft_collection_address,
                    )?,
                )
            }
            QueryMsg::GetNftForSaleInfo { nft_collection_address, token_id } => {
                to_binary(
                    &crate::query::query_nft_for_sale(
                        deps,
                        nft_collection_address,
                        token_id,
                    )?,
                )
            }
            QueryMsg::GetSellerAllNftsForSale {
                seller_address,
                start_after_collection_token_id: start_after_token_id,
                output_length,
            } => {
                to_binary(
                    &crate::query::query_nfts_for_sale_from_seller(
                        deps,
                        seller_address,
                        start_after_token_id,
                        output_length,
                    )?,
                )
            }
            QueryMsg::GetAllTokensByCollAndIfForSale {
                address,
                nft_collection_address,
                output_length,
            } => {
                to_binary(
                    &crate::query::query_all_tokens_by_coll_and_if_sale(
                        deps,
                        address,
                        nft_collection_address,
                        output_length,
                    )?,
                )
            }
            QueryMsg::GetCollectionAllNftsForSale {
                nft_collection_address,
                start_after_token_id,
                output_length,
            } => {
                to_binary(
                    &crate::query::query_nfts_for_sale_from_collection(
                        deps,
                        nft_collection_address,
                        start_after_token_id,
                        output_length,
                    )?,
                )
            }
            QueryMsg::GetMarketplaceInfo {} => {
                to_binary(&crate::query::query_marketplace_info(deps)?)
            }
            QueryMsg::GetTokenIdSaleHistory { nft_collection_address, token_id } => {
                to_binary(
                    &crate::query::query_nft_trade_history(
                        deps,
                        nft_collection_address,
                        token_id,
                    )?,
                )
            }
            QueryMsg::GetProfileInfo { address_or_username } => {
                to_binary(&crate::query::query_profile_info(deps, address_or_username)?)
            }
            QueryMsg::GetAllOffersTokenId {
                token_id,
                nft_collection_address,
                start_after,
                output_length,
            } => {
                to_binary(
                    &crate::query::query_nft_offers_by_token_id(
                        deps,
                        nft_collection_address,
                        token_id,
                        start_after,
                        output_length,
                    )?,
                )
            }
            QueryMsg::GetAllOffersAddress { address, start_after, output_length } => {
                to_binary(
                    &crate::query::query_nft_offers_from_offerer(
                        deps,
                        address,
                        start_after,
                        output_length,
                    )?,
                )
            }
            QueryMsg::GetTokenIdsByCollection { address, list_of_collections } => {
                to_binary(
                    &crate::query::query_token_ids_by_collection(
                        deps,
                        address,
                        list_of_collections,
                    )?,
                )
            }
        }
    }
}
pub mod execute_functions {
    pub mod add_new_nft_collection {
        use cosmwasm_std::{Deps, DepsMut, Env, MessageInfo, Response};
        use general_utils::error::ContractError;
        use general_utils::error::NftMarketplaceError::{
            InvalidNftCollection, NftCollectionAlreadyExists,
        };
        use nft_marketplace_utils::nft_collection::{
            define_unique_collection_by_denom_id, nft_collection_denoms,
            NftCollectionAddress, NftCollectionInfoAndUsdcVol, NftCollectionInfoByDenom,
            NftContractType,
        };
        use nft_marketplace_utils::response_handler::ResponseHandler;
        use crate::helper_functions::royalties::validate_contract_type_and_royalty;
        use crate::state::{
            CONFIG, GENERAL_STATS, LISTED_NFT_COLLECTIONS_INFO_AND_USDC_VOL,
        };
        pub fn execute_add_new_nft_collection(
            mut deps: DepsMut,
            _env: Env,
            _info: MessageInfo,
            nft_collection_address: NftCollectionAddress,
            nft_contract_type: NftContractType,
        ) -> Result<Response, ContractError> {
            validate_input_and_if_coll_already_exists(
                deps.as_ref(),
                &nft_collection_address,
            )?;
            let new_info = save_new_collection_info_to_storage(
                deps.branch(),
                &nft_collection_address,
                nft_contract_type,
            )?;
            validate_contract_type_and_royalty(new_info, deps.querier)?;
            Ok(ResponseHandler::add_nft_collection(&nft_collection_address).response)
        }
        fn validate_input_and_if_coll_already_exists(
            deps: Deps,
            nft_collection_address: &str,
        ) -> Result<(), ContractError> {
            deps.querier.query_wasm_contract_info(nft_collection_address.to_string())?;
            if LISTED_NFT_COLLECTIONS_INFO_AND_USDC_VOL
                .has(deps.storage, nft_collection_address)
            {
                return Err(ContractError::NftMarketplaceError(NftCollectionAlreadyExists {}));
            }
            Ok(())
        }
        fn save_new_collection_info_to_storage(
            mut deps: DepsMut,
            nft_collection_address: &str,
            nft_contract_type: NftContractType,
        ) -> Result<NftCollectionInfoAndUsdcVol, ContractError> {
            create_nft_collection_denoms_state(
                deps.branch(),
                nft_collection_address.to_string(),
            )?;
            let new_info = NftCollectionInfoAndUsdcVol::new(
                nft_collection_address.to_string(),
                nft_contract_type,
            );
            LISTED_NFT_COLLECTIONS_INFO_AND_USDC_VOL
                .save(deps.storage, nft_collection_address, &new_info)?;
            GENERAL_STATS
                .update(
                    deps.storage,
                    |mut gen_stats| -> Result<_, ContractError> {
                        gen_stats
                            .last_collection_added = nft_collection_address.to_string();
                        Ok(gen_stats)
                    },
                )?;
            Ok(new_info)
        }
        fn create_nft_collection_denoms_state(
            deps: DepsMut,
            nft_collection_address: NftCollectionAddress,
        ) -> Result<(), ContractError> {
            let config = CONFIG.load(deps.storage)?;
            let collections = config
                .accepted_ibc_denominations
                .list_of_denoms
                .iter()
                .map(|accepted_denom| {
                    NftCollectionInfoByDenom::new_checked(
                        deps.querier,
                        nft_collection_address.clone(),
                        accepted_denom.clone(),
                    )
                })
                .collect::<Result<Vec<_>, _>>()?;
            collections
                .into_iter()
                .try_for_each(|collection| {
                    let collection_denom_unique = define_unique_collection_by_denom_id(
                        &nft_collection_address,
                        &collection.denom,
                    );
                    nft_collection_denoms()
                        .save(deps.storage, collection_denom_unique, &collection)
                })
                .map_err(|_| ContractError::NftMarketplaceError(InvalidNftCollection {}))?;
            Ok(())
        }
    }
    pub mod answer_offer {
        use cosmwasm_std::{DepsMut, Env, MessageInfo, Response, WasmMsg};
        use general_utils::error::ContractError;
        use nft_marketplace_utils::nft_collection::{NftCollectionAddress, TokenId};
        use nft_marketplace_utils::nft_offer::{define_unique_offer, nft_offers};
        use nft_marketplace_utils::nft_sale::NftSale;
        use nft_marketplace_utils::response_handler::ResponseHandler;
        use crate::msg::ExecuteMsg;
        use crate::query;
        use crate::state::CONFIG;
        #[allow(clippy::too_many_arguments)]
        pub fn execute_answer_offer(
            deps: DepsMut,
            env: Env,
            info: MessageInfo,
            nft_collection_address: NftCollectionAddress,
            token_id: TokenId,
            from: String,
            if_accepted: bool,
            answer_msg: Option<String>,
        ) -> Result<Response, ContractError> {
            let config = CONFIG.load(deps.storage)?;
            let unique_offer = define_unique_offer(
                &nft_collection_address,
                &token_id,
                &from,
            );
            let nft_offer_loaded = nft_offers()
                .load(deps.storage, unique_offer.clone())?;
            if !if_accepted
                || nft_offer_loaded.offer_expiration.clone().seconds()
                    < env.block.time.seconds()
            {
                let exec_cancel_sale_msg_inner = ExecuteMsg::wasm_execute_cancel_offer(
                    nft_collection_address,
                    env.contract.address.to_string(),
                    token_id,
                    nft_offer_loaded.offerer_address.clone(),
                )?;
                return Ok(
                    ResponseHandler::execute_rejected_or_expired_offer(
                            exec_cancel_sale_msg_inner.unwrap(),
                            nft_offer_loaded,
                            if_accepted,
                            match answer_msg {
                                Some(string) => string,
                                None => "None".to_string(),
                            },
                        )
                        .unwrap()
                        .response,
                );
            }
            nft_offers().remove(deps.storage, unique_offer)?;
            let not_for_sale = query::query_nft_for_sale(
                    deps.as_ref(),
                    nft_collection_address.clone(),
                    token_id.clone(),
                )
                .is_err();
            let execute_cancel_message: Option<WasmMsg> = if !not_for_sale {
                ExecuteMsg::wasm_execute_message_cancel_sale(
                    nft_collection_address.clone(),
                    env.contract.address.to_string(),
                    token_id.clone(),
                    info.sender.to_string(),
                )?
            } else {
                None
            };
            let execute_sell_nft_msg_inner = ExecuteMsg::wasm_execute_message_sell(
                config.marketplace_listing_fee_value,
                env.contract.address.to_string(),
                NftSale {
                    seller: info.sender.to_string(),
                    nft_collection_address: nft_collection_address.clone(),
                    token_id: token_id.clone(),
                    sale_price_value: nft_offer_loaded.offer_price_value,
                    sale_price_denom: nft_offer_loaded.offer_price_denom.clone(),
                    sale_expiration: nft_offer_loaded.offer_expiration,
                },
                config.marketplace_listing_fee_denom,
            )?;
            let execute_buy_nft_msg_inner = ExecuteMsg::wasm_execute_buy_nft(
                nft_collection_address,
                env.contract.address.to_string(),
                token_id,
                nft_offer_loaded.offerer_address.clone(),
                nft_offer_loaded.offer_price_value,
                nft_offer_loaded.offer_price_denom.clone(),
            )?;
            Ok(
                ResponseHandler::execute_accept_offer(
                        info.sender.to_string(),
                        nft_offer_loaded.offerer_address,
                        execute_cancel_message,
                        execute_sell_nft_msg_inner.unwrap(),
                        execute_buy_nft_msg_inner.unwrap(),
                        match answer_msg {
                            Some(string) => string,
                            None => "None".to_string(),
                        },
                    )
                    .response,
            )
        }
    }
    pub mod buy_nft {
        use cosmwasm_std::{
            DepsMut, Env, MessageInfo, QueryRequest, Response, StdResult, Timestamp,
            to_binary, Uint128, WasmQuery,
        };
        use general_utils::error::ContractError;
        use general_utils::error::GenericError::DivisionError;
        use general_utils::error::NftMarketplaceError::{
            AdditionalInfoNeedsToBeFilled, CantUseAdditionalInfoIfNotContract,
        };
        use nft_marketplace_utils::inputs::Buyer;
        use nft_marketplace_utils::marketplace_statistics::CollectionVolume;
        use nft_marketplace_utils::nft_collection::{
            define_unique_collection_by_denom_id, nft_collection_denoms,
            NftCollectionAddress, TokenId,
        };
        use nft_marketplace_utils::nft_sale::{
            compute_floor_collection_and_denom, define_unique_collection_nft_id,
            nfts_for_sale, TokenSaleHistory,
        };
        use nft_marketplace_utils::profile::{Profile, TradeInfo};
        use nft_marketplace_utils::response_handler::ResponseHandler;
        use crate::constants::{MARKETPLACE_USDC_INDICATOR, MAX_PRICE};
        use crate::helper_functions::royalties::compute_royalty;
        use crate::query;
        use crate::state::{
            CONFIG, GENERAL_STATS, LISTED_NFT_COLLECTIONS_INFO_AND_USDC_VOL,
            MARKETPLACE_STATS_BY_DENOM, PROFILES, REWARD_SYSTEM, TOKEN_SALE_HISTORY,
        };
        pub fn execute_buy_nft(
            deps: DepsMut,
            env: Env,
            mut info: MessageInfo,
            mut nft_collection_address: NftCollectionAddress,
            token_id: TokenId,
            additional_info: Option<String>,
        ) -> Result<Response, ContractError> {
            let config = CONFIG.load(deps.storage)?;
            nft_collection_address = deps
                .api
                .addr_validate(&nft_collection_address)?
                .to_string();
            let nft_for_sale_info = query::query_nft_for_sale(
                deps.as_ref(),
                nft_collection_address.clone(),
                token_id.clone(),
            )?;
            if let Some(additional_info) = additional_info {
                if info.sender != env.contract.address {
                    return Err(
                        ContractError::NftMarketplaceError(CantUseAdditionalInfoIfNotContract {}),
                    );
                }
                info = MessageInfo {
                    sender: deps.api.addr_validate(&additional_info)?,
                    funds: info.funds.clone(),
                };
            } else {
                if info.sender == env.contract.address {
                    return Err(
                        ContractError::NftMarketplaceError(AdditionalInfoNeedsToBeFilled {}),
                    );
                }
            }
            let buyer = Buyer::new_checked(
                deps.api.addr_validate(info.sender.as_ref())?,
                info.funds,
            )?;
            let collection_token_id_unique = define_unique_collection_nft_id(
                &nft_collection_address,
                &token_id,
            );
            nft_for_sale_info.clone().validate_buying_information(&buyer)?;
            nfts_for_sale().remove(deps.storage, collection_token_id_unique.clone())?;
            let new_floor = compute_floor_collection_and_denom(
                deps.storage,
                nft_for_sale_info.clone().sale_price_denom,
                nft_for_sale_info.clone().nft_collection_address,
                MAX_PRICE,
            )?;
            let collection_denom_unique: String = define_unique_collection_by_denom_id(
                &nft_for_sale_info.nft_collection_address,
                &nft_for_sale_info.sale_price_denom,
            );
            let is_expired = nft_for_sale_info.sale_expiration.seconds()
                <= env.block.time.seconds();
            MARKETPLACE_STATS_BY_DENOM
                .update(
                    deps.storage,
                    &nft_for_sale_info.clone().sale_price_denom,
                    |mp_info| -> Result<_, ContractError> {
                        let mut mp_info = mp_info.unwrap();
                        if is_expired {
                            mp_info.remove_nft_for_sale();
                        } else {
                            mp_info
                                .execute_sale(
                                    nft_for_sale_info.clone().sale_price_value,
                                    config.marketplace_pct_fees,
                                );
                        }
                        Ok(mp_info)
                    },
                )?;
            nft_collection_denoms()
                .update(
                    deps.storage,
                    collection_denom_unique,
                    |nft_coll_denom| -> Result<_, ContractError> {
                        let mut nft_coll_denom = nft_coll_denom.unwrap();
                        if is_expired {
                            nft_coll_denom = nft_coll_denom.expired_sale(new_floor);
                        } else {
                            nft_coll_denom = nft_coll_denom
                                .execute_sale(
                                    nft_for_sale_info.clone().sale_price_value,
                                    new_floor,
                                );
                        }
                        Ok(nft_coll_denom)
                    },
                )?;
            if is_expired {
                return Ok(ResponseHandler::expired_nft_sale_response(buyer).response);
            }
            let maybe_history: Option<Vec<TokenSaleHistory>> = TOKEN_SALE_HISTORY
                .may_load(deps.storage, &collection_token_id_unique)?;
            let transaction_info = TokenSaleHistory {
                seller: nft_for_sale_info.seller.clone(),
                buyer: buyer.sender.clone(),
                nft_collection_address: nft_for_sale_info.nft_collection_address.clone(),
                token_id: nft_for_sale_info.token_id.clone(),
                sale_price_value: nft_for_sale_info.sale_price_value,
                sale_price_denom: nft_for_sale_info.sale_price_denom.clone(),
                sale_time: Timestamp::from_seconds(env.block.time.seconds()),
            };
            let mut new_vector_of_transactions = maybe_history.unwrap_or_default();
            new_vector_of_transactions.push(transaction_info);
            TOKEN_SALE_HISTORY
                .save(
                    deps.storage,
                    &collection_token_id_unique,
                    &new_vector_of_transactions,
                )?;
            let nft_collection_info = LISTED_NFT_COLLECTIONS_INFO_AND_USDC_VOL
                .load(deps.storage, &nft_collection_address)?;
            let nft_royalties = compute_royalty(
                nft_for_sale_info.clone(),
                nft_collection_info,
                deps.as_ref(),
            )?;
            let nft_price_usdc: Uint128 = deps
                .querier
                .query::<
                    Uint128,
                >(
                    &QueryRequest::Wasm(WasmQuery::Smart {
                        contract_addr: config.oracle_contract_address.clone(),
                        msg: to_binary(
                            &crypto_assets_price_oracle::msg::QueryMsg::GetUsdcPriceFromAmountAndDenom {
                                amount: nft_for_sale_info.sale_price_value,
                                denom: nft_for_sale_info.sale_price_denom.clone(),
                            },
                        )?,
                    }),
                )?;
            for nft_col in <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([
                        nft_for_sale_info.nft_collection_address.clone(),
                        MARKETPLACE_USDC_INDICATOR.to_string(),
                    ]),
                )
                .iter()
            {
                LISTED_NFT_COLLECTIONS_INFO_AND_USDC_VOL
                    .update(
                        deps.storage,
                        nft_col,
                        |mp_info| -> StdResult<_> {
                            let mut mp_info_u = mp_info.unwrap();
                            mp_info_u.usdc_volume += nft_price_usdc;
                            Ok(mp_info_u)
                        },
                    )?;
            }
            let mut gen_stats = GENERAL_STATS.load(deps.storage)?;
            let current_collection_usdc_volume = LISTED_NFT_COLLECTIONS_INFO_AND_USDC_VOL
                .load(deps.storage, &nft_for_sale_info.nft_collection_address)?
                .usdc_volume;
            if current_collection_usdc_volume > gen_stats.lowest_volume_usdc
                || gen_stats.top_10_volume_usdc.len() < 10
            {
                gen_stats
                    .compute_new_top_10_and_latest_collection_traded(CollectionVolume {
                        nft_collection_address: nft_collection_address.clone(),
                        usdc_volume: current_collection_usdc_volume,
                    });
                GENERAL_STATS.save(deps.storage, &gen_stats)?;
            }
            let mut buyer_profile: Profile = Profile::new(buyer.sender.clone());
            if !PROFILES.has(deps.storage, &buyer.sender)
                && buyer.sender != env.contract.address
            {
                PROFILES.save(deps.storage, &buyer.sender, &buyer_profile)?;
            }
            let mut seller_profile: Profile = Profile::new(
                nft_for_sale_info.seller.clone(),
            );
            if !PROFILES.has(deps.storage, &nft_for_sale_info.seller)
                && info.sender != env.contract.address
            {
                PROFILES.save(deps.storage, &nft_for_sale_info.seller, &seller_profile)?;
            }
            let sale_price_trade_info = TradeInfo {
                denom: nft_for_sale_info.sale_price_denom.clone(),
                volume_value: nft_for_sale_info.sale_price_value,
            };
            PROFILES
                .update(
                    deps.storage,
                    &nft_for_sale_info.seller,
                    |profile| -> Result<_, ContractError> {
                        let mut profile_u = profile.unwrap();
                        seller_profile = profile_u.clone();
                        profile_u = profile_u
                            .realise_transaction(
                                None,
                                Some(sale_price_trade_info.clone()),
                            )
                            .unwrap();
                        profile_u = profile_u
                            .nft_used_in_profile_check_and_reset(
                                token_id.clone(),
                                nft_collection_address.clone(),
                            )?;
                        Ok(profile_u)
                    },
                )?;
            PROFILES
                .update(
                    deps.storage,
                    info.sender.as_ref(),
                    |profile| -> Result<_, ContractError> {
                        let mut profile_u = profile.unwrap();
                        buyer_profile = profile_u.clone();
                        profile_u = profile_u
                            .realise_transaction(
                                Some(sale_price_trade_info.clone()),
                                None,
                            )
                            .unwrap();
                        Ok(profile_u)
                    },
                )?;
            let reward_system = REWARD_SYSTEM.load(deps.storage)?;
            REWARD_SYSTEM
                .update(
                    deps.storage,
                    |mut updated_reward_system| -> Result<_, ContractError> {
                        let current_distribution: Uint128 = nft_price_usdc
                            .checked_div(
                                updated_reward_system.reward_token_per_1usdc_volume,
                            )
                            .map_err(|_| ContractError::Generic(DivisionError {}))?
                            .checked_mul(Uint128::new(2_000_000u128))
                            .map_err(|_| ContractError::Generic(DivisionError {}))?;
                        updated_reward_system.total_reward_tokens_distributed
                            += current_distribution;
                        Ok(updated_reward_system)
                    },
                )?;
            Ok(
                ResponseHandler::execute_succes_nft_sale_response(
                        deps.as_ref(),
                        buyer,
                        nft_for_sale_info,
                        config.marketplace_pct_fees,
                        nft_royalties,
                        seller_profile,
                        buyer_profile,
                        reward_system,
                        nft_price_usdc,
                    )?
                    .response,
            )
        }
    }
    pub mod cancel_nft_sale {
        use std::marker::PhantomData;
        use cosmwasm_std::{Addr, DepsMut, Empty, Env, MessageInfo, Response};
        use cw721_base::helpers::Cw721Contract;
        use general_utils::error::ContractError;
        use general_utils::error::NftMarketplaceError::{
            AdditionalInfoNeedsToBeFilled, CantUseAdditionalInfoIfNotContract,
            RevokeYourApprovalBeforeCancellingSale,
        };
        use nft_marketplace_utils::nft_collection::{
            define_unique_collection_by_denom_id, nft_collection_denoms,
            NftCollectionAddress, TokenId,
        };
        use nft_marketplace_utils::nft_sale::{
            compute_floor_collection_and_denom, define_unique_collection_nft_id,
            nfts_for_sale,
        };
        use nft_marketplace_utils::response_handler::ResponseHandler;
        use crate::constants::MAX_PRICE;
        use crate::state::MARKETPLACE_STATS_BY_DENOM;
        pub fn execute_cancel_nft_sale(
            deps: DepsMut,
            env: Env,
            mut info: MessageInfo,
            mut nft_collection_address: NftCollectionAddress,
            token_id: TokenId,
            additional_info: Option<String>,
        ) -> Result<Response, ContractError> {
            nft_collection_address = deps
                .api
                .addr_validate(&nft_collection_address)?
                .to_string();
            if let Some(addr) = &additional_info {
                if info.sender != env.contract.address {
                    return Err(
                        ContractError::NftMarketplaceError(CantUseAdditionalInfoIfNotContract {}),
                    );
                }
                info = MessageInfo {
                    sender: deps.api.addr_validate(addr)?,
                    funds: info.funds.clone(),
                };
            } else if info.sender == env.contract.address {
                return Err(
                    ContractError::NftMarketplaceError(AdditionalInfoNeedsToBeFilled {}),
                );
            }
            let owner_response = Cw721Contract::<
                Empty,
                Empty,
            >(deps.api.addr_validate(&nft_collection_address)?, PhantomData, PhantomData)
                .owner_of(&deps.querier, token_id.clone(), false)?;
            let collection_token_id_unique = define_unique_collection_nft_id(
                &nft_collection_address,
                &token_id,
            );
            let mut nft_for_sale_info = nfts_for_sale()
                .load(deps.storage, collection_token_id_unique.clone())?;
            nft_for_sale_info = nft_for_sale_info
                .validate_sender_is_token_owner(
                    info.sender.as_ref(),
                    env.contract.address.as_ref(),
                    &owner_response.owner,
                )?;
            if additional_info.is_none() {
                let cw721_contract = Cw721Contract::<
                    Empty,
                    Empty,
                >(Addr::unchecked(nft_collection_address), PhantomData, PhantomData);
                if cw721_contract
                    .approval(
                        &deps.querier,
                        token_id,
                        env.contract.address.to_string(),
                        None,
                    )
                    .is_ok()
                {
                    return Err(
                        ContractError::NftMarketplaceError(RevokeYourApprovalBeforeCancellingSale {}),
                    );
                }
            }
            MARKETPLACE_STATS_BY_DENOM
                .update(
                    deps.storage,
                    &*nft_for_sale_info.sale_price_denom,
                    |mp_info| -> Result<_, ContractError> {
                        Ok(mp_info.unwrap().remove_nft_for_sale().clone())
                    },
                )?;
            let collection_denom_unique = define_unique_collection_by_denom_id(
                &nft_for_sale_info.nft_collection_address,
                &nft_for_sale_info.sale_price_denom,
            );
            nfts_for_sale().remove(deps.storage, collection_token_id_unique)?;
            let new_floor = compute_floor_collection_and_denom(
                deps.storage,
                nft_for_sale_info.sale_price_denom.clone(),
                nft_for_sale_info.nft_collection_address.clone(),
                MAX_PRICE,
            )?;
            nft_collection_denoms()
                .update(
                    deps.storage,
                    collection_denom_unique,
                    |nft_coll_denom| -> Result<_, ContractError> {
                        Ok(nft_coll_denom.unwrap().remove_sale(new_floor))
                    },
                )?;
            Ok(ResponseHandler::cancel_nft_sale_response(nft_for_sale_info).response)
        }
    }
    pub mod cancel_offer {
        use cosmwasm_std::{DepsMut, Env, MessageInfo, Response};
        use general_utils::error::ContractError;
        use general_utils::error::NftMarketplaceError::{
            AdditionalInfoNeedsToBeFilled, CantUseAdditionalInfoIfNotContract,
        };
        use nft_marketplace_utils::nft_collection::{NftCollectionAddress, TokenId};
        use nft_marketplace_utils::nft_offer::{define_unique_offer, nft_offers};
        use nft_marketplace_utils::response_handler::ResponseHandler;
        pub fn execute_cancel_offer(
            deps: DepsMut,
            env: Env,
            mut info: MessageInfo,
            nft_collection_address: NftCollectionAddress,
            token_id: TokenId,
            additional_info: Option<String>,
        ) -> Result<Response, ContractError> {
            let sender = match (additional_info.clone(), info.sender.clone()) {
                (Some(_), sender) if sender != env.contract.address => {
                    return Err(
                        ContractError::NftMarketplaceError(CantUseAdditionalInfoIfNotContract {}),
                    );
                }
                (None, sender) if sender == env.contract.address => {
                    return Err(
                        ContractError::NftMarketplaceError(AdditionalInfoNeedsToBeFilled {}),
                    );
                }
                (Some(addr), _) => addr,
                (None, sender) => sender.into(),
            };
            let unique_offer = define_unique_offer(
                &nft_collection_address,
                &token_id,
                &sender,
            );
            let nft_offer_loaded = nft_offers()
                .load(deps.storage, unique_offer.clone())?;
            if nft_offer_loaded.offerer_address != info.sender
                && info.sender == env.contract.address
            {
                info.sender = deps.api.addr_validate(&additional_info.unwrap())?;
            }
            nft_offers().remove(deps.storage, unique_offer)?;
            Ok(ResponseHandler::nft_cancel_offer_response(nft_offer_loaded).response)
        }
    }
    pub mod claim_marketplace_fees {
        use cosmwasm_std::{DepsMut, Response, Uint128};
        use general_utils::denominations::DenominationValue;
        use general_utils::error::ContractError;
        use nft_marketplace_utils::response_handler::ResponseHandler;
        use crate::state::{CONFIG, MARKETPLACE_STATS_BY_DENOM};
        pub fn execute_claim_marketplace_fees(
            deps: DepsMut,
        ) -> Result<Response, ContractError> {
            let config = CONFIG.load(deps.storage)?;
            let all_accepted_denoms_value: Vec<DenominationValue> = config
                .accepted_ibc_denominations
                .list_of_denoms
                .iter()
                .map(|denom| {
                    let mut mp_fees: Uint128 = Uint128::zero();
                    MARKETPLACE_STATS_BY_DENOM
                        .update(
                            deps.storage,
                            denom,
                            |mp_info| -> Result<_, ContractError> {
                                let mut mp_info_u = mp_info.unwrap();
                                mp_fees = mp_info_u.marketplace_fees_to_claim;
                                mp_info_u.marketplace_fees_to_claim = Uint128::zero();
                                Ok(mp_info_u)
                            },
                        )?;
                    Ok::<
                        DenominationValue,
                        ContractError,
                    >(DenominationValue {
                        denom: denom.clone(),
                        value: mp_fees,
                    })
                })
                .collect::<Result<Vec<_>, _>>()?;
            let non_zero_denoms: Vec<DenominationValue> = all_accepted_denoms_value
                .into_iter()
                .filter(|dv| dv.value != Uint128::zero())
                .collect();
            Ok(
                ResponseHandler::claim_marketplace_fees(
                        config.contract_owner,
                        non_zero_denoms,
                    )
                    .response,
            )
        }
    }
    pub mod create_profile {
        use cosmwasm_std::{DepsMut, Env, MessageInfo, Response};
        use general_utils::error::ContractError;
        use general_utils::error::NftMarketplaceError::{
            AdditionalInfoNeedsToBeFilled, CantUseAdditionalInfoIfNotContract,
            YourProfileAlreadyExists,
        };
        use nft_marketplace_utils::profile::Profile;
        use nft_marketplace_utils::response_handler::ResponseHandler;
        use crate::state::PROFILES;
        pub fn execute_create_profile(
            deps: DepsMut,
            env: Env,
            mut info: MessageInfo,
            additional_info: Option<String>,
        ) -> Result<Response, ContractError> {
            if let Some(addr) = &additional_info {
                if info.sender != env.contract.address {
                    return Err(
                        ContractError::NftMarketplaceError(CantUseAdditionalInfoIfNotContract {}),
                    );
                }
                info = MessageInfo {
                    sender: deps.api.addr_validate(&addr.to_string())?,
                    funds: info.funds.clone(),
                };
            } else if info.sender == env.contract.address {
                return Err(
                    ContractError::NftMarketplaceError(AdditionalInfoNeedsToBeFilled {}),
                );
            }
            let sender_addr = deps.api.addr_validate(info.sender.as_ref())?.to_string();
            if PROFILES.has(deps.storage, &sender_addr) {
                return Err(ContractError::NftMarketplaceError(YourProfileAlreadyExists {}));
            }
            let new_profile = Profile::new(info.sender.to_string());
            PROFILES.save(deps.storage, &sender_addr, &new_profile)?;
            Ok(ResponseHandler::create_or_update_profile(new_profile).unwrap().response)
        }
    }
    pub mod instantiate {
        use std::str::FromStr;
        use cosmwasm_std::{
            Decimal, DepsMut, MessageInfo, QueryRequest, Response, to_binary, Uint128,
            WasmQuery,
        };
        use general_utils::error::ContractError;
        use nft_marketplace_utils::config::Config;
        use nft_marketplace_utils::marketplace_statistics::{
            GeneralStats, MarketplaceStatsByDenom,
        };
        use nft_marketplace_utils::nft_collection::{
            NftCollectionInfoAndUsdcVol, NftContractType,
        };
        use nft_marketplace_utils::response_handler::ResponseHandler;
        use nft_marketplace_utils::reward_system::RewardSystem;
        use crate::constants::MARKETPLACE_USDC_INDICATOR;
        use crate::msg::InstantiateMsg;
        use crate::state::{
            CONFIG, GENERAL_STATS, LISTED_NFT_COLLECTIONS_INFO_AND_USDC_VOL,
            MARKETPLACE_STATS_BY_DENOM, REWARD_SYSTEM,
        };
        pub fn instantiate_contract(
            deps: DepsMut,
            _info: MessageInfo,
            init_msg: InstantiateMsg,
        ) -> Result<Response, ContractError> {
            deps.querier
                .query::<
                    Uint128,
                >(
                    &QueryRequest::Wasm(WasmQuery::Smart {
                        contract_addr: init_msg.oracle_contract_address.clone(),
                        msg: to_binary(
                            &crypto_assets_price_oracle::msg::QueryMsg::GetUsdcPriceFromAmountAndDenom {
                                amount: Uint128::new(100_000_000_000u128),
                                denom: init_msg.marketplace_listing_fee_denom.clone(),
                            },
                        )?,
                    }),
                )?;
            deps.querier
                .query_wasm_contract_info(
                    init_msg.reward_system.reward_token_address.clone(),
                )?;
            CONFIG
                .save(
                    deps.storage,
                    &Config::new_checked(
                        deps.api,
                        false,
                        init_msg.contract_owner,
                        init_msg.accepted_ibc_denominations.clone(),
                        Decimal::from_str(&init_msg.marketplace_pct_fees_decimal_string)
                            .unwrap(),
                        init_msg.marketplace_listing_fee_value,
                        init_msg.marketplace_listing_fee_denom,
                        init_msg.oracle_contract_address,
                    )?,
                )?;
            REWARD_SYSTEM
                .save(
                    deps.storage,
                    &RewardSystem::new_checked(
                        deps.api,
                        init_msg.reward_system.reward_token_address,
                        init_msg.reward_system.reward_token_per_1usdc_volume,
                        init_msg.reward_system.total_reward_tokens_distributed,
                        init_msg.reward_system.vip_perks,
                    )?,
                )?;
            init_msg
                .accepted_ibc_denominations
                .list_of_denoms
                .iter()
                .try_for_each(|accepted_denom| {
                    MARKETPLACE_STATS_BY_DENOM
                        .save(
                            deps.storage,
                            accepted_denom,
                            &MarketplaceStatsByDenom::new(accepted_denom.clone()),
                        )
                })?;
            LISTED_NFT_COLLECTIONS_INFO_AND_USDC_VOL
                .save(
                    deps.storage,
                    MARKETPLACE_USDC_INDICATOR,
                    &NftCollectionInfoAndUsdcVol::new(
                        MARKETPLACE_USDC_INDICATOR.to_string(),
                        NftContractType::MarketplaceInfo,
                    ),
                )?;
            GENERAL_STATS.save(deps.storage, &GeneralStats::new())?;
            Ok(ResponseHandler::init_response().response)
        }
    }
    pub mod level_up_profile {
        use cosmwasm_std::{DepsMut, Env, MessageInfo, Response, Uint128};
        use general_utils::error::ContractError;
        use nft_marketplace_utils::profile::Profile;
        use nft_marketplace_utils::response_handler::ResponseHandler;
        use nft_marketplace_utils::reward_system::{RewardSystem, VipLevel};
        use crate::state::{PROFILES, REWARD_SYSTEM};
        pub fn execute_level_up_profile(
            deps: DepsMut,
            _env: Env,
            _info: MessageInfo,
            mut user_sender: String,
            cw20_amount: Uint128,
        ) -> Result<Response, ContractError> {
            user_sender = deps.api.addr_validate(&user_sender)?.to_string();
            let reward_system: RewardSystem = REWARD_SYSTEM.load(deps.storage)?;
            let mut loaded_profile: Profile = PROFILES
                .load(deps.storage, user_sender.as_ref())?;
            let previous_level = loaded_profile.vip_level.clone();
            if VipLevel::level_up_if_possible(
                loaded_profile.vip_level.clone().unwrap(),
                reward_system.vip_perks,
                cw20_amount,
            )? {
                loaded_profile = loaded_profile.level_up();
                PROFILES.save(deps.storage, user_sender.as_ref(), &loaded_profile)?;
            }
            Ok(
                ResponseHandler::level_up_profile(
                        previous_level.unwrap(),
                        loaded_profile.vip_level.unwrap(),
                    )?
                    .response,
            )
        }
    }
    pub mod offer {
        use cosmwasm_std::{DepsMut, Env, MessageInfo, Response, WasmMsg};
        use general_utils::error::ContractError;
        use general_utils::error::NftMarketplaceError::{
            NftCollectionNotListed, OfferAlreadyExists,
        };
        use nft_marketplace_utils::config::Config;
        use nft_marketplace_utils::nft_offer::{
            define_unique_offer, nft_offers, NftOffer,
        };
        use nft_marketplace_utils::response_handler::ResponseHandler;
        use crate::constants::{
            MAX_EXPIRATION_SECONDS, MAX_PRICE, MIN_EXPIRATION_SECONDS, MIN_PRICE,
        };
        use crate::msg::ExecuteMsg;
        use crate::state::{CONFIG, LISTED_NFT_COLLECTIONS_INFO_AND_USDC_VOL, PROFILES};
        pub fn execute_offer(
            deps: DepsMut,
            env: Env,
            info: MessageInfo,
            mut offer: NftOffer,
        ) -> Result<Response, ContractError> {
            let config: Config = CONFIG.load(deps.storage)?;
            offer
                .nft_collection_address = deps
                .api
                .addr_validate(&offer.nft_collection_address)?
                .to_string();
            offer
                .offerer_address = deps
                .api
                .addr_validate(&offer.offerer_address)?
                .to_string();
            if !LISTED_NFT_COLLECTIONS_INFO_AND_USDC_VOL
                .has(deps.storage, &offer.nft_collection_address)
            {
                return Err(ContractError::NftMarketplaceError(NftCollectionNotListed {}));
            }
            let mut create_profile_msg: Option<WasmMsg> = None;
            if !PROFILES.has(deps.storage, info.sender.as_ref())
                && info.sender != env.contract.address
            {
                create_profile_msg = ExecuteMsg::wasm_execute_message_create_profile(
                    env.contract.address.to_string(),
                    Some(info.sender.to_string()),
                )?;
            }
            let unique_offer_id = define_unique_offer(
                &offer.nft_collection_address,
                &offer.token_id,
                &offer.offerer_address.to_string(),
            );
            if nft_offers().has(deps.storage, unique_offer_id.clone()) {
                return Err(ContractError::NftMarketplaceError(OfferAlreadyExists {}));
            }
            let nft_offer_validated: NftOffer = NftOffer::new_checked(
                deps.as_ref(),
                offer,
                &info,
                env.block.time.seconds(),
                config.accepted_ibc_denominations,
                MAX_EXPIRATION_SECONDS,
                MIN_EXPIRATION_SECONDS,
                MAX_PRICE,
                MIN_PRICE,
            )?;
            nft_offers().save(deps.storage, unique_offer_id, &nft_offer_validated)?;
            Ok(
                ResponseHandler::nft_offer_response(
                        nft_offer_validated,
                        create_profile_msg,
                    )
                    .response,
            )
        }
    }
    pub mod receive_cw20 {
        use cosmwasm_std::{DepsMut, Env, from_binary, MessageInfo, Response};
        use cw20::Cw20ReceiveMsg;
        use general_utils::error::ContractError;
        use general_utils::error::GenericError::InvalidDenominationReceived;
        use crate::execute_functions::level_up_profile;
        use crate::msg;
        use crate::state::REWARD_SYSTEM;
        pub fn execute_receive_cw20(
            deps: DepsMut,
            info: MessageInfo,
            wrapper: Cw20ReceiveMsg,
            _env: Env,
        ) -> Result<Response, ContractError> {
            let reward_system = REWARD_SYSTEM.load(deps.storage)?;
            let cw20_msg: msg::ReceiveMsg = from_binary(&wrapper.msg)?;
            let cw20_denom = deps.api.addr_validate(info.sender.as_ref())?;
            if cw20_denom != reward_system.reward_token_address {
                return Err(ContractError::Generic(InvalidDenominationReceived {}));
            }
            let user_sender = wrapper.sender.clone();
            let cw20_amount = wrapper.amount;
            match cw20_msg {
                msg::ReceiveMsg::LevelUpProfile {} => {
                    level_up_profile::execute_level_up_profile(
                        deps,
                        _env,
                        info,
                        user_sender,
                        cw20_amount,
                    )
                }
            }
        }
    }
    pub mod sell_nft {
        use cosmwasm_std::{DepsMut, Env, MessageInfo, Response, WasmMsg};
        use general_utils::error::ContractError;
        use general_utils::error::NftMarketplaceError::{
            NftCollectionNotListed, SaleAlreadyExists,
        };
        use nft_marketplace_utils::nft_collection::{
            define_unique_collection_by_denom_id, nft_collection_denoms,
            NftCollectionInfoByDenom,
        };
        use nft_marketplace_utils::nft_sale::{
            define_unique_collection_nft_id, nfts_for_sale, NftSale,
        };
        use nft_marketplace_utils::response_handler::ResponseHandler;
        use crate::constants::{
            MAX_EXPIRATION_SECONDS, MAX_PRICE, MIN_EXPIRATION_SECONDS, MIN_PRICE,
        };
        use crate::msg::ExecuteMsg;
        use crate::state::{
            CONFIG, LISTED_NFT_COLLECTIONS_INFO_AND_USDC_VOL, MARKETPLACE_STATS_BY_DENOM,
            PROFILES,
        };
        pub fn execute_sell_nft(
            deps: DepsMut,
            env: Env,
            mut info: MessageInfo,
            mut sale_info: NftSale,
        ) -> Result<Response, ContractError> {
            let config = CONFIG.load(deps.storage)?;
            sale_info.seller = deps.api.addr_validate(&sale_info.seller)?.to_string();
            sale_info
                .nft_collection_address = deps
                .api
                .addr_validate(&sale_info.nft_collection_address)?
                .to_string();
            let mut create_profile_msg: Option<WasmMsg> = None;
            if !PROFILES.has(deps.storage, info.sender.as_ref())
                && info.sender != env.contract.address
            {
                create_profile_msg = ExecuteMsg::wasm_execute_message_create_profile(
                    env.contract.address.to_string(),
                    Some(info.sender.to_string()),
                )?;
            }
            if !LISTED_NFT_COLLECTIONS_INFO_AND_USDC_VOL
                .has(deps.storage, &sale_info.nft_collection_address)
            {
                return Err(ContractError::NftMarketplaceError(NftCollectionNotListed {}));
            }
            if info.sender == env.contract.address {
                info.sender = deps.api.addr_validate(&sale_info.seller)?;
            } else {
                MARKETPLACE_STATS_BY_DENOM
                    .update(
                        deps.storage,
                        &*config.marketplace_listing_fee_denom,
                        |mp_info| -> Result<_, ContractError> {
                            Ok(
                                mp_info
                                    .unwrap()
                                    .add_listing_fees(&config.marketplace_listing_fee_value)
                                    .clone(),
                            )
                        },
                    )?;
            }
            let nft_for_sale_validated: NftSale = NftSale::new_checked(
                deps.as_ref(),
                &env.block.time.seconds(),
                &info,
                &sale_info,
                config,
                env.contract.address.to_string(),
                MAX_EXPIRATION_SECONDS,
                MIN_EXPIRATION_SECONDS,
                MAX_PRICE,
                MIN_PRICE,
            )?;
            MARKETPLACE_STATS_BY_DENOM
                .update(
                    deps.storage,
                    &*nft_for_sale_validated.sale_price_denom,
                    |mp_info| -> Result<_, ContractError> {
                        Ok(mp_info.unwrap().list_nft_for_sale().clone())
                    },
                )?;
            let collection_token_id_unique: String = define_unique_collection_nft_id(
                &nft_for_sale_validated.nft_collection_address,
                &nft_for_sale_validated.token_id,
            );
            if nfts_for_sale().has(deps.storage, collection_token_id_unique.clone()) {
                return Err(ContractError::NftMarketplaceError(SaleAlreadyExists {}));
            }
            let collection_denom_unique: String = define_unique_collection_by_denom_id(
                &nft_for_sale_validated.nft_collection_address,
                &nft_for_sale_validated.sale_price_denom,
            );
            if !(nft_collection_denoms()
                .has(deps.storage, collection_denom_unique.clone()))
            {
                nft_collection_denoms()
                    .save(
                        deps.storage,
                        collection_denom_unique.clone(),
                        &NftCollectionInfoByDenom::new_checked(
                            deps.querier,
                            nft_for_sale_validated.nft_collection_address.clone(),
                            nft_for_sale_validated.sale_price_denom.clone(),
                        )?,
                    )?;
            }
            nft_collection_denoms()
                .update(
                    deps.storage,
                    collection_denom_unique,
                    |nft_coll_denom| -> Result<_, ContractError> {
                        Ok(
                            nft_coll_denom
                                .unwrap()
                                .register_sale(nft_for_sale_validated.clone()),
                        )
                    },
                )?;
            nfts_for_sale()
                .save(
                    deps.storage,
                    collection_token_id_unique,
                    &nft_for_sale_validated,
                )?;
            Ok(
                ResponseHandler::register_nft_sale_response(
                        nft_for_sale_validated,
                        create_profile_msg,
                    )
                    .response,
            )
        }
    }
    pub mod send_message {
        use cosmwasm_std::{Addr, DepsMut, Env, MessageInfo, Response};
        use general_utils::error::ContractError;
        use general_utils::error::NftMarketplaceError::{
            InvalidMessage, ReceiverDoesNotExist,
        };
        use nft_marketplace_utils::profile::Profile;
        use nft_marketplace_utils::response_handler::ResponseHandler;
        use crate::state::{PROFILES, USERNAMES};
        pub fn execute_send_message(
            deps: DepsMut,
            _env: Env,
            info: MessageInfo,
            to: String,
            message: String,
        ) -> Result<Response, ContractError> {
            if !(message.is_ascii() && message.chars().all(|c| c.is_ascii()))
                || message.len() > 120
            {
                return Err(ContractError::NftMarketplaceError(InvalidMessage {}));
            }
            let sender_username: Option<String> = if !PROFILES
                .has(deps.storage, info.sender.as_ref())
            {
                let profile = Profile::new(info.sender.to_string());
                PROFILES.save(deps.storage, info.sender.as_ref(), &profile)?;
                None
            } else {
                let profile = PROFILES.load(deps.storage, info.sender.as_ref())?;
                profile.username
            };
            let mut receiver_username = Some("Does not exist".to_string());
            let mut validated_receiver = deps.api.addr_validate(&to);
            if validated_receiver.is_err() {
                if !USERNAMES.has(deps.storage, &to) {
                    return Err(ContractError::NftMarketplaceError(ReceiverDoesNotExist {}));
                } else {
                    validated_receiver = Ok(
                        Addr::unchecked(USERNAMES.load(deps.storage, &to)?),
                    );
                    receiver_username = Some(to);
                }
            }
            let receiver = validated_receiver?.to_string();
            let receiver_profile = PROFILES.load(deps.storage, &receiver)?;
            let updated_receiver_profile = receiver_profile
                .receive_message(
                    info.sender.to_string(),
                    sender_username.clone(),
                    message,
                );
            PROFILES.save(deps.storage, &receiver, &updated_receiver_profile)?;
            Ok(
                ResponseHandler::send_message(
                        info.sender.to_string(),
                        sender_username,
                        receiver,
                        receiver_username,
                    )
                    .response,
            )
        }
    }
    pub mod transfer_my_nft {
        use cosmwasm_std::{DepsMut, Env, MessageInfo, Response, WasmMsg};
        use general_utils::error::ContractError;
        use general_utils::error::NftMarketplaceError::{
            CantCancelASaleYouDontOwn, NftCollectionNotListed,
        };
        use nft_marketplace_utils::nft_collection::{NftCollectionAddress, TokenId};
        use nft_marketplace_utils::nft_sale::check_if_sender_is_owner_token_id_exists_and_can_transfer;
        use nft_marketplace_utils::response_handler::ResponseHandler;
        use crate::msg::ExecuteMsg;
        use crate::query;
        use crate::state::{LISTED_NFT_COLLECTIONS_INFO_AND_USDC_VOL, PROFILES};
        pub fn execute_transfer_my_nft(
            deps: DepsMut,
            env: Env,
            info: MessageInfo,
            nft_collection_address: NftCollectionAddress,
            token_id: TokenId,
            mut recipient: String,
        ) -> Result<Response, ContractError> {
            recipient = deps.api.addr_validate(&recipient)?.to_string();
            let mut create_profile_msg: Option<WasmMsg> = None;
            if !PROFILES.has(deps.storage, info.sender.as_ref()) {
                create_profile_msg = ExecuteMsg::wasm_execute_message_create_profile(
                    env.contract.address.to_string(),
                    Some(info.sender.to_string()),
                )?;
            }
            if !LISTED_NFT_COLLECTIONS_INFO_AND_USDC_VOL
                .has(deps.storage, &nft_collection_address)
            {
                return Err(ContractError::NftMarketplaceError(NftCollectionNotListed {}));
            }
            check_if_sender_is_owner_token_id_exists_and_can_transfer(
                deps.as_ref(),
                &nft_collection_address,
                token_id.clone(),
                info.sender.to_string(),
                env.contract.address.to_string(),
            )?;
            let exec_cancel_sale_msg_inner = match query::query_nft_for_sale(
                deps.as_ref(),
                nft_collection_address.clone(),
                token_id.clone(),
            ) {
                Ok(sale) => {
                    if sale.seller != info.sender {
                        return Err(
                            ContractError::NftMarketplaceError(CantCancelASaleYouDontOwn {}),
                        );
                    }
                    Some(
                        ExecuteMsg::wasm_execute_message_cancel_sale(
                                nft_collection_address.to_string(),
                                env.contract.address.to_string(),
                                token_id.clone(),
                                info.sender.to_string(),
                            )?
                            .unwrap(),
                    )
                }
                Err(_) => None,
            };
            if PROFILES.has(deps.storage, info.sender.as_ref()) {
                PROFILES
                    .update(
                        deps.storage,
                        info.sender.as_ref(),
                        |profile| -> Result<_, ContractError> {
                            let mut profile_u = profile.unwrap();
                            profile_u = profile_u
                                .nft_used_in_profile_check_and_reset(
                                    token_id.clone(),
                                    nft_collection_address.clone(),
                                )?;
                            Ok(profile_u)
                        },
                    )?;
            }
            Ok(
                ResponseHandler::transfer_my_nft(
                        token_id,
                        nft_collection_address,
                        recipient,
                        create_profile_msg,
                        exec_cancel_sale_msg_inner,
                    )?
                    .response,
            )
        }
    }
    pub mod update_config {
        use cosmwasm_std::{DepsMut, Env, MessageInfo, Response};
        use general_utils::error::ContractError;
        use nft_marketplace_utils::response_handler::ResponseHandler;
        use crate::msg::UpdateConfigEnum;
        use crate::state::{CONFIG, REWARD_SYSTEM};
        pub fn execute_update_config(
            deps: DepsMut,
            _env: Env,
            _info: MessageInfo,
            list_of_updates: Vec<UpdateConfigEnum>,
        ) -> Result<Response, ContractError> {
            let mut config = CONFIG.load(deps.storage)?;
            for update in list_of_updates {
                match update {
                    UpdateConfigEnum::EnableDisable {} => {
                        config.contract_enabled = !config.contract_enabled;
                    }
                    UpdateConfigEnum::AddDenoms { denoms } => {
                        config.accepted_ibc_denominations.add_many(denoms);
                    }
                    UpdateConfigEnum::RemoveDenoms { denoms } => {
                        config.accepted_ibc_denominations.remove_many(denoms);
                    }
                    UpdateConfigEnum::UpdateOwner { address } => {
                        config
                            .contract_owner = deps
                            .api
                            .addr_validate(&address.to_string())?
                            .to_string();
                    }
                    UpdateConfigEnum::UpdateRewardSystem { reward_system } => {
                        REWARD_SYSTEM.save(deps.storage, &reward_system)?;
                    }
                }
            }
            CONFIG.save(deps.storage, &config)?;
            Ok(ResponseHandler::update_config().response)
        }
    }
    pub mod update_nft_sale {
        use std::marker::PhantomData;
        use cosmwasm_std::{DepsMut, Empty, Env, MessageInfo, Response};
        use cw721_base::helpers::Cw721Contract;
        use general_utils::error::ContractError;
        use nft_marketplace_utils::nft_sale::{
            define_unique_collection_nft_id, nfts_for_sale, NftSale,
        };
        use nft_marketplace_utils::response_handler::ResponseHandler;
        use crate::msg::ExecuteMsg;
        use crate::state::CONFIG;
        pub fn execute_update_nft_sale(
            deps: DepsMut,
            env: Env,
            info: MessageInfo,
            mut sale_info: NftSale,
        ) -> Result<Response, ContractError> {
            sale_info
                .nft_collection_address = deps
                .api
                .addr_validate(&sale_info.nft_collection_address)?
                .to_string();
            sale_info.seller = deps.api.addr_validate(&sale_info.seller)?.to_string();
            let config = CONFIG.load(deps.storage)?;
            let collection_token_id_unique = define_unique_collection_nft_id(
                &sale_info.nft_collection_address,
                &sale_info.token_id,
            );
            let mut nft_for_sale_info = nfts_for_sale()
                .load(deps.storage, collection_token_id_unique)?;
            let owner_response = Cw721Contract::<
                Empty,
                Empty,
            >(
                    deps.api.addr_validate(&sale_info.nft_collection_address)?,
                    PhantomData,
                    PhantomData,
                )
                .owner_of(&deps.querier, sale_info.token_id.to_string(), false)?;
            nft_for_sale_info = nft_for_sale_info
                .validate_sender_is_token_owner(
                    info.sender.as_ref(),
                    env.contract.address.as_ref(),
                    &owner_response.owner,
                )?;
            let cancel_sale_msg = ExecuteMsg::wasm_execute_message_cancel_sale(
                nft_for_sale_info.nft_collection_address.clone(),
                env.contract.address.to_string(),
                nft_for_sale_info.token_id.clone(),
                nft_for_sale_info.seller,
            )?;
            let execute_sale_msg = ExecuteMsg::wasm_execute_message_sell(
                config.marketplace_listing_fee_value,
                env.contract.address.to_string(),
                sale_info,
                config.marketplace_listing_fee_denom,
            )?;
            Ok(
                ResponseHandler::execute_update_sale(
                        cancel_sale_msg.unwrap(),
                        execute_sale_msg.unwrap(),
                    )
                    .response,
            )
        }
    }
    pub mod update_profile {
        use cosmwasm_std::{DepsMut, Env, MessageInfo, Response};
        use general_utils::error::ContractError;
        use nft_marketplace_utils::profile::{Profile, ProfileUpdateAction};
        use nft_marketplace_utils::response_handler::ResponseHandler;
        use crate::state::{PROFILES, REWARD_SYSTEM, USERNAMES};
        pub fn execute_update_profile(
            deps: DepsMut,
            _env: Env,
            info: MessageInfo,
            mut new_profile: Profile,
            profile_update_action: ProfileUpdateAction,
        ) -> Result<Response, ContractError> {
            let sender_addr = info.sender.to_string();
            let reward_system = REWARD_SYSTEM.load(deps.storage)?;
            let current_profile = PROFILES.load(deps.storage, &sender_addr)?;
            if new_profile.username.is_some()
                && profile_update_action == ProfileUpdateAction::Add
            {
                if USERNAMES.has(deps.storage, &new_profile.username.clone().unwrap()) {
                    new_profile.username = None;
                }
            }
            let updated_profile = current_profile
                .clone()
                .user_update_profile(
                    deps.as_ref(),
                    new_profile,
                    reward_system,
                    profile_update_action,
                )?;
            if updated_profile.username != current_profile.username {
                if updated_profile.username.is_some() {
                    if current_profile.username.is_some() {
                        USERNAMES
                            .remove(deps.storage, &current_profile.username.unwrap());
                    }
                    USERNAMES
                        .save(
                            deps.storage,
                            &updated_profile.username.clone().unwrap(),
                            &sender_addr,
                        )?;
                }
            }
            PROFILES.save(deps.storage, &sender_addr, &updated_profile)?;
            Ok(ResponseHandler::create_or_update_profile(updated_profile)?.response)
        }
    }
}
pub mod msg {
    use cosmwasm_schema::{cw_serde, QueryResponses};
    use cosmwasm_std::{coins, to_binary, Uint128, WasmMsg};
    use cw20::Cw20ReceiveMsg;
    use general_utils::denominations::{AcceptedDenominations, Denomination};
    use general_utils::error::ContractError;
    use nft_marketplace_utils::nft_collection::{
        NftCollectionAddress, NftCollectionAddressTokenId, NftContractType, TokenId,
    };
    use nft_marketplace_utils::nft_offer::NftOffer;
    use nft_marketplace_utils::nft_sale::NftSale;
    use nft_marketplace_utils::profile::{Profile, ProfileUpdateAction};
    use nft_marketplace_utils::reward_system::RewardSystem;
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[serde(deny_unknown_fields, crate = "::cosmwasm_schema::serde")]
    #[schemars(crate = "::cosmwasm_schema::schemars")]
    pub struct InstantiateMsg {
        pub contract_owner: String,
        pub accepted_ibc_denominations: AcceptedDenominations,
        pub marketplace_pct_fees_decimal_string: String,
        pub marketplace_listing_fee_value: Uint128,
        pub marketplace_listing_fee_denom: Denomination,
        pub oracle_contract_address: String,
        pub reward_system: RewardSystem,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use ::cosmwasm_schema::serde as _serde;
        #[automatically_derived]
        impl ::cosmwasm_schema::serde::Serialize for InstantiateMsg {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> ::cosmwasm_schema::serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: ::cosmwasm_schema::serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "InstantiateMsg",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "contract_owner",
                    &self.contract_owner,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "accepted_ibc_denominations",
                    &self.accepted_ibc_denominations,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "marketplace_pct_fees_decimal_string",
                    &self.marketplace_pct_fees_decimal_string,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "marketplace_listing_fee_value",
                    &self.marketplace_listing_fee_value,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "marketplace_listing_fee_denom",
                    &self.marketplace_listing_fee_denom,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "oracle_contract_address",
                    &self.oracle_contract_address,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "reward_system",
                    &self.reward_system,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use ::cosmwasm_schema::serde as _serde;
        #[automatically_derived]
        impl<'de> ::cosmwasm_schema::serde::Deserialize<'de> for InstantiateMsg {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> ::cosmwasm_schema::serde::__private::Result<Self, __D::Error>
            where
                __D: ::cosmwasm_schema::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"field index 0 <= i < 7",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "contract_owner" => _serde::__private::Ok(__Field::__field0),
                            "accepted_ibc_denominations" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            "marketplace_pct_fees_decimal_string" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            "marketplace_listing_fee_value" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            "marketplace_listing_fee_denom" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            "oracle_contract_address" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            "reward_system" => _serde::__private::Ok(__Field::__field6),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"contract_owner" => _serde::__private::Ok(__Field::__field0),
                            b"accepted_ibc_denominations" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            b"marketplace_pct_fees_decimal_string" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"marketplace_listing_fee_value" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            b"marketplace_listing_fee_denom" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            b"oracle_contract_address" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            b"reward_system" => _serde::__private::Ok(__Field::__field6),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                )
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<InstantiateMsg>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = InstantiateMsg;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct InstantiateMsg",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct InstantiateMsg with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            AcceptedDenominations,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct InstantiateMsg with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct InstantiateMsg with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match match _serde::de::SeqAccess::next_element::<
                            Uint128,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct InstantiateMsg with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match match _serde::de::SeqAccess::next_element::<
                            Denomination,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct InstantiateMsg with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct InstantiateMsg with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match match _serde::de::SeqAccess::next_element::<
                            RewardSystem,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct InstantiateMsg with 7 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(InstantiateMsg {
                            contract_owner: __field0,
                            accepted_ibc_denominations: __field1,
                            marketplace_pct_fees_decimal_string: __field2,
                            marketplace_listing_fee_value: __field3,
                            marketplace_listing_fee_denom: __field4,
                            oracle_contract_address: __field5,
                            reward_system: __field6,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            AcceptedDenominations,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Uint128> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<Denomination> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<RewardSystem> = _serde::__private::None;
                        while let _serde::__private::Some(__key)
                            = match _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "contract_owner",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            String,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "accepted_ibc_denominations",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            AcceptedDenominations,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "marketplace_pct_fees_decimal_string",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            String,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "marketplace_listing_fee_value",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Uint128,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "marketplace_listing_fee_denom",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Denomination,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "oracle_contract_address",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            String,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "reward_system",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            RewardSystem,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field(
                                    "contract_owner",
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field(
                                    "accepted_ibc_denominations",
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field(
                                    "marketplace_pct_fees_decimal_string",
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field(
                                    "marketplace_listing_fee_value",
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field(
                                    "marketplace_listing_fee_denom",
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field(
                                    "oracle_contract_address",
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field(
                                    "reward_system",
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(InstantiateMsg {
                            contract_owner: __field0,
                            accepted_ibc_denominations: __field1,
                            marketplace_pct_fees_decimal_string: __field2,
                            marketplace_listing_fee_value: __field3,
                            marketplace_listing_fee_denom: __field4,
                            oracle_contract_address: __field5,
                            reward_system: __field6,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &[
                    "contract_owner",
                    "accepted_ibc_denominations",
                    "marketplace_pct_fees_decimal_string",
                    "marketplace_listing_fee_value",
                    "marketplace_listing_fee_denom",
                    "oracle_contract_address",
                    "reward_system",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "InstantiateMsg",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<InstantiateMsg>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for InstantiateMsg {
        #[inline]
        fn clone(&self) -> InstantiateMsg {
            InstantiateMsg {
                contract_owner: ::core::clone::Clone::clone(&self.contract_owner),
                accepted_ibc_denominations: ::core::clone::Clone::clone(
                    &self.accepted_ibc_denominations,
                ),
                marketplace_pct_fees_decimal_string: ::core::clone::Clone::clone(
                    &self.marketplace_pct_fees_decimal_string,
                ),
                marketplace_listing_fee_value: ::core::clone::Clone::clone(
                    &self.marketplace_listing_fee_value,
                ),
                marketplace_listing_fee_denom: ::core::clone::Clone::clone(
                    &self.marketplace_listing_fee_denom,
                ),
                oracle_contract_address: ::core::clone::Clone::clone(
                    &self.oracle_contract_address,
                ),
                reward_system: ::core::clone::Clone::clone(&self.reward_system),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::fmt::Debug for InstantiateMsg {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "contract_owner",
                "accepted_ibc_denominations",
                "marketplace_pct_fees_decimal_string",
                "marketplace_listing_fee_value",
                "marketplace_listing_fee_denom",
                "oracle_contract_address",
                "reward_system",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.contract_owner,
                &self.accepted_ibc_denominations,
                &self.marketplace_pct_fees_decimal_string,
                &self.marketplace_listing_fee_value,
                &self.marketplace_listing_fee_denom,
                &self.oracle_contract_address,
                &&self.reward_system,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "InstantiateMsg",
                names,
                values,
            )
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for InstantiateMsg {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for InstantiateMsg {
        #[inline]
        fn eq(&self, other: &InstantiateMsg) -> bool {
            self.contract_owner == other.contract_owner
                && self.accepted_ibc_denominations == other.accepted_ibc_denominations
                && self.marketplace_pct_fees_decimal_string
                    == other.marketplace_pct_fees_decimal_string
                && self.marketplace_listing_fee_value
                    == other.marketplace_listing_fee_value
                && self.marketplace_listing_fee_denom
                    == other.marketplace_listing_fee_denom
                && self.oracle_contract_address == other.oracle_contract_address
                && self.reward_system == other.reward_system
        }
    }
    const _: () = {
        use ::cosmwasm_schema::schemars as schemars;
        #[automatically_derived]
        #[allow(unused_braces)]
        impl schemars::JsonSchema for InstantiateMsg {
            fn schema_name() -> std::string::String {
                "InstantiateMsg".to_owned()
            }
            fn json_schema(
                gen: &mut schemars::gen::SchemaGenerator,
            ) -> schemars::schema::Schema {
                {
                    let mut schema_object = schemars::schema::SchemaObject {
                        instance_type: Some(
                            schemars::schema::InstanceType::Object.into(),
                        ),
                        ..Default::default()
                    };
                    let object_validation = schema_object.object();
                    object_validation
                        .additional_properties = Some(Box::new(false.into()));
                    {
                        object_validation
                            .properties
                            .insert(
                                "contract_owner".to_owned(),
                                gen.subschema_for::<String>(),
                            );
                        if !<String as schemars::JsonSchema>::_schemars_private_is_option() {
                            object_validation
                                .required
                                .insert("contract_owner".to_owned());
                        }
                    }
                    {
                        object_validation
                            .properties
                            .insert(
                                "accepted_ibc_denominations".to_owned(),
                                gen.subschema_for::<AcceptedDenominations>(),
                            );
                        if !<AcceptedDenominations as schemars::JsonSchema>::_schemars_private_is_option() {
                            object_validation
                                .required
                                .insert("accepted_ibc_denominations".to_owned());
                        }
                    }
                    {
                        object_validation
                            .properties
                            .insert(
                                "marketplace_pct_fees_decimal_string".to_owned(),
                                gen.subschema_for::<String>(),
                            );
                        if !<String as schemars::JsonSchema>::_schemars_private_is_option() {
                            object_validation
                                .required
                                .insert("marketplace_pct_fees_decimal_string".to_owned());
                        }
                    }
                    {
                        object_validation
                            .properties
                            .insert(
                                "marketplace_listing_fee_value".to_owned(),
                                gen.subschema_for::<Uint128>(),
                            );
                        if !<Uint128 as schemars::JsonSchema>::_schemars_private_is_option() {
                            object_validation
                                .required
                                .insert("marketplace_listing_fee_value".to_owned());
                        }
                    }
                    {
                        object_validation
                            .properties
                            .insert(
                                "marketplace_listing_fee_denom".to_owned(),
                                gen.subschema_for::<Denomination>(),
                            );
                        if !<Denomination as schemars::JsonSchema>::_schemars_private_is_option() {
                            object_validation
                                .required
                                .insert("marketplace_listing_fee_denom".to_owned());
                        }
                    }
                    {
                        object_validation
                            .properties
                            .insert(
                                "oracle_contract_address".to_owned(),
                                gen.subschema_for::<String>(),
                            );
                        if !<String as schemars::JsonSchema>::_schemars_private_is_option() {
                            object_validation
                                .required
                                .insert("oracle_contract_address".to_owned());
                        }
                    }
                    {
                        object_validation
                            .properties
                            .insert(
                                "reward_system".to_owned(),
                                gen.subschema_for::<RewardSystem>(),
                            );
                        if !<RewardSystem as schemars::JsonSchema>::_schemars_private_is_option() {
                            object_validation
                                .required
                                .insert("reward_system".to_owned());
                        }
                    }
                    schemars::schema::Schema::Object(schema_object)
                }
            }
        }
    };
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[serde(
        deny_unknown_fields,
        rename_all = "snake_case",
        crate = "::cosmwasm_schema::serde"
    )]
    #[schemars(crate = "::cosmwasm_schema::schemars")]
    #[allow(clippy::large_enum_variant)]
    pub enum ExecuteMsg {
        UpdateConfig { list_of_updates: Vec<UpdateConfigEnum> },
        ClaimMarketplaceFees {},
        AddNewCollection {
            nft_collection_address: NftCollectionAddress,
            nft_contract_type: NftContractType,
        },
        TransferMyNft {
            nft_collection_address: NftCollectionAddress,
            token_id: TokenId,
            recipient: String,
        },
        SellNft { sale_info: NftSale },
        CancelSale {
            nft_collection_address: NftCollectionAddress,
            token_id: TokenId,
            additional_info: Option<String>,
        },
        UpdateSale { sale_info: NftSale },
        BuyNft {
            nft_collection_address: NftCollectionAddress,
            token_id: TokenId,
            additional_info: Option<String>,
        },
        Offer { offer: NftOffer },
        CancelOffer {
            nft_collection_address: NftCollectionAddress,
            token_id: TokenId,
            additional_info: Option<String>,
        },
        AnswerOffer {
            nft_collection_address: NftCollectionAddress,
            token_id: TokenId,
            from: String,
            if_accepted: bool,
            answer_msg: Option<String>,
        },
        CreateMyProfile { additional_info: Option<String> },
        UpdateMyProfile { profile: Profile, profile_update_action: ProfileUpdateAction },
        SendMessage { to: String, message: String },
        Receive(Cw20ReceiveMsg),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use ::cosmwasm_schema::serde as _serde;
        #[automatically_derived]
        impl ::cosmwasm_schema::serde::Serialize for ExecuteMsg {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> ::cosmwasm_schema::serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: ::cosmwasm_schema::serde::Serializer,
            {
                match *self {
                    ExecuteMsg::UpdateConfig { ref list_of_updates } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "ExecuteMsg",
                            0u32,
                            "update_config",
                            0 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "list_of_updates",
                            list_of_updates,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    ExecuteMsg::ClaimMarketplaceFees {} => {
                        let __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "ExecuteMsg",
                            1u32,
                            "claim_marketplace_fees",
                            0,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    ExecuteMsg::AddNewCollection {
                        ref nft_collection_address,
                        ref nft_contract_type,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "ExecuteMsg",
                            2u32,
                            "add_new_collection",
                            0 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "nft_collection_address",
                            nft_collection_address,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "nft_contract_type",
                            nft_contract_type,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    ExecuteMsg::TransferMyNft {
                        ref nft_collection_address,
                        ref token_id,
                        ref recipient,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "ExecuteMsg",
                            3u32,
                            "transfer_my_nft",
                            0 + 1 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "nft_collection_address",
                            nft_collection_address,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "token_id",
                            token_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "recipient",
                            recipient,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    ExecuteMsg::SellNft { ref sale_info } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "ExecuteMsg",
                            4u32,
                            "sell_nft",
                            0 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "sale_info",
                            sale_info,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    ExecuteMsg::CancelSale {
                        ref nft_collection_address,
                        ref token_id,
                        ref additional_info,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "ExecuteMsg",
                            5u32,
                            "cancel_sale",
                            0 + 1 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "nft_collection_address",
                            nft_collection_address,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "token_id",
                            token_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "additional_info",
                            additional_info,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    ExecuteMsg::UpdateSale { ref sale_info } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "ExecuteMsg",
                            6u32,
                            "update_sale",
                            0 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "sale_info",
                            sale_info,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    ExecuteMsg::BuyNft {
                        ref nft_collection_address,
                        ref token_id,
                        ref additional_info,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "ExecuteMsg",
                            7u32,
                            "buy_nft",
                            0 + 1 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "nft_collection_address",
                            nft_collection_address,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "token_id",
                            token_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "additional_info",
                            additional_info,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    ExecuteMsg::Offer { ref offer } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "ExecuteMsg",
                            8u32,
                            "offer",
                            0 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "offer",
                            offer,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    ExecuteMsg::CancelOffer {
                        ref nft_collection_address,
                        ref token_id,
                        ref additional_info,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "ExecuteMsg",
                            9u32,
                            "cancel_offer",
                            0 + 1 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "nft_collection_address",
                            nft_collection_address,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "token_id",
                            token_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "additional_info",
                            additional_info,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    ExecuteMsg::AnswerOffer {
                        ref nft_collection_address,
                        ref token_id,
                        ref from,
                        ref if_accepted,
                        ref answer_msg,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "ExecuteMsg",
                            10u32,
                            "answer_offer",
                            0 + 1 + 1 + 1 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "nft_collection_address",
                            nft_collection_address,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "token_id",
                            token_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "from",
                            from,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "if_accepted",
                            if_accepted,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "answer_msg",
                            answer_msg,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    ExecuteMsg::CreateMyProfile { ref additional_info } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "ExecuteMsg",
                            11u32,
                            "create_my_profile",
                            0 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "additional_info",
                            additional_info,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    ExecuteMsg::UpdateMyProfile {
                        ref profile,
                        ref profile_update_action,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "ExecuteMsg",
                            12u32,
                            "update_my_profile",
                            0 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "profile",
                            profile,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "profile_update_action",
                            profile_update_action,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    ExecuteMsg::SendMessage { ref to, ref message } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "ExecuteMsg",
                            13u32,
                            "send_message",
                            0 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "to",
                            to,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "message",
                            message,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    ExecuteMsg::Receive(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "ExecuteMsg",
                            14u32,
                            "receive",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use ::cosmwasm_schema::serde as _serde;
        #[automatically_derived]
        impl<'de> ::cosmwasm_schema::serde::Deserialize<'de> for ExecuteMsg {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> ::cosmwasm_schema::serde::__private::Result<Self, __D::Error>
            where
                __D: ::cosmwasm_schema::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __field12,
                    __field13,
                    __field14,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            11u64 => _serde::__private::Ok(__Field::__field11),
                            12u64 => _serde::__private::Ok(__Field::__field12),
                            13u64 => _serde::__private::Ok(__Field::__field13),
                            14u64 => _serde::__private::Ok(__Field::__field14),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 15",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "update_config" => _serde::__private::Ok(__Field::__field0),
                            "claim_marketplace_fees" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            "add_new_collection" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            "transfer_my_nft" => _serde::__private::Ok(__Field::__field3),
                            "sell_nft" => _serde::__private::Ok(__Field::__field4),
                            "cancel_sale" => _serde::__private::Ok(__Field::__field5),
                            "update_sale" => _serde::__private::Ok(__Field::__field6),
                            "buy_nft" => _serde::__private::Ok(__Field::__field7),
                            "offer" => _serde::__private::Ok(__Field::__field8),
                            "cancel_offer" => _serde::__private::Ok(__Field::__field9),
                            "answer_offer" => _serde::__private::Ok(__Field::__field10),
                            "create_my_profile" => {
                                _serde::__private::Ok(__Field::__field11)
                            }
                            "update_my_profile" => {
                                _serde::__private::Ok(__Field::__field12)
                            }
                            "send_message" => _serde::__private::Ok(__Field::__field13),
                            "receive" => _serde::__private::Ok(__Field::__field14),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"update_config" => _serde::__private::Ok(__Field::__field0),
                            b"claim_marketplace_fees" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            b"add_new_collection" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"transfer_my_nft" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            b"sell_nft" => _serde::__private::Ok(__Field::__field4),
                            b"cancel_sale" => _serde::__private::Ok(__Field::__field5),
                            b"update_sale" => _serde::__private::Ok(__Field::__field6),
                            b"buy_nft" => _serde::__private::Ok(__Field::__field7),
                            b"offer" => _serde::__private::Ok(__Field::__field8),
                            b"cancel_offer" => _serde::__private::Ok(__Field::__field9),
                            b"answer_offer" => _serde::__private::Ok(__Field::__field10),
                            b"create_my_profile" => {
                                _serde::__private::Ok(__Field::__field11)
                            }
                            b"update_my_profile" => {
                                _serde::__private::Ok(__Field::__field12)
                            }
                            b"send_message" => _serde::__private::Ok(__Field::__field13),
                            b"receive" => _serde::__private::Ok(__Field::__field14),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ExecuteMsg>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ExecuteMsg;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum ExecuteMsg",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 1",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "list_of_updates" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"list_of_updates" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<ExecuteMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = ExecuteMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant ExecuteMsg::UpdateConfig",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            Vec<UpdateConfigEnum>,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant ExecuteMsg::UpdateConfig with 1 element",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(ExecuteMsg::UpdateConfig {
                                            list_of_updates: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            Vec<UpdateConfigEnum>,
                                        > = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "list_of_updates",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Vec<UpdateConfigEnum>,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "list_of_updates",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(ExecuteMsg::UpdateConfig {
                                            list_of_updates: __field0,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[
                                    "list_of_updates",
                                ];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<ExecuteMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field1, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {}
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 0",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<ExecuteMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = ExecuteMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant ExecuteMsg::ClaimMarketplaceFees",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        _: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        _serde::__private::Ok(ExecuteMsg::ClaimMarketplaceFees {
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        _serde::__private::Option::map(
                                            match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                            |__impossible| match __impossible {},
                                        );
                                        _serde::__private::Ok(ExecuteMsg::ClaimMarketplaceFees {
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<ExecuteMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field2, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 2",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            "nft_contract_type" => {
                                                _serde::__private::Ok(__Field::__field1)
                                            }
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            b"nft_contract_type" => {
                                                _serde::__private::Ok(__Field::__field1)
                                            }
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<ExecuteMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = ExecuteMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant ExecuteMsg::AddNewCollection",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            NftCollectionAddress,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant ExecuteMsg::AddNewCollection with 2 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                                            NftContractType,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        1usize,
                                                        &"struct variant ExecuteMsg::AddNewCollection with 2 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(ExecuteMsg::AddNewCollection {
                                            nft_collection_address: __field0,
                                            nft_contract_type: __field1,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            NftCollectionAddress,
                                        > = _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<
                                            NftContractType,
                                        > = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "nft_collection_address",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            NftCollectionAddress,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "nft_contract_type",
                                                            ),
                                                        );
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            NftContractType,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "nft_collection_address",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "nft_contract_type",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(ExecuteMsg::AddNewCollection {
                                            nft_collection_address: __field0,
                                            nft_contract_type: __field1,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[
                                    "nft_collection_address",
                                    "nft_contract_type",
                                ];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<ExecuteMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field3, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __field2,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            2u64 => _serde::__private::Ok(__Field::__field2),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 3",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            "token_id" => _serde::__private::Ok(__Field::__field1),
                                            "recipient" => _serde::__private::Ok(__Field::__field2),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            b"token_id" => _serde::__private::Ok(__Field::__field1),
                                            b"recipient" => _serde::__private::Ok(__Field::__field2),
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<ExecuteMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = ExecuteMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant ExecuteMsg::TransferMyNft",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            NftCollectionAddress,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant ExecuteMsg::TransferMyNft with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                                            TokenId,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        1usize,
                                                        &"struct variant ExecuteMsg::TransferMyNft with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                                            String,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        2usize,
                                                        &"struct variant ExecuteMsg::TransferMyNft with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(ExecuteMsg::TransferMyNft {
                                            nft_collection_address: __field0,
                                            token_id: __field1,
                                            recipient: __field2,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            NftCollectionAddress,
                                        > = _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<TokenId> = _serde::__private::None;
                                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "nft_collection_address",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            NftCollectionAddress,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "token_id",
                                                            ),
                                                        );
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            TokenId,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field2 => {
                                                    if _serde::__private::Option::is_some(&__field2) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "recipient",
                                                            ),
                                                        );
                                                    }
                                                    __field2 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            String,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "nft_collection_address",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("token_id") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field2 = match __field2 {
                                            _serde::__private::Some(__field2) => __field2,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("recipient") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(ExecuteMsg::TransferMyNft {
                                            nft_collection_address: __field0,
                                            token_id: __field1,
                                            recipient: __field2,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[
                                    "nft_collection_address",
                                    "token_id",
                                    "recipient",
                                ];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<ExecuteMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field4, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 1",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "sale_info" => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"sale_info" => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<ExecuteMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = ExecuteMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant ExecuteMsg::SellNft",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            NftSale,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant ExecuteMsg::SellNft with 1 element",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(ExecuteMsg::SellNft {
                                            sale_info: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<NftSale> = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "sale_info",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            NftSale,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("sale_info") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(ExecuteMsg::SellNft {
                                            sale_info: __field0,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["sale_info"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<ExecuteMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field5, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __field2,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            2u64 => _serde::__private::Ok(__Field::__field2),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 3",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            "token_id" => _serde::__private::Ok(__Field::__field1),
                                            "additional_info" => {
                                                _serde::__private::Ok(__Field::__field2)
                                            }
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            b"token_id" => _serde::__private::Ok(__Field::__field1),
                                            b"additional_info" => {
                                                _serde::__private::Ok(__Field::__field2)
                                            }
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<ExecuteMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = ExecuteMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant ExecuteMsg::CancelSale",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            NftCollectionAddress,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant ExecuteMsg::CancelSale with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                                            TokenId,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        1usize,
                                                        &"struct variant ExecuteMsg::CancelSale with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                                            Option<String>,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        2usize,
                                                        &"struct variant ExecuteMsg::CancelSale with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(ExecuteMsg::CancelSale {
                                            nft_collection_address: __field0,
                                            token_id: __field1,
                                            additional_info: __field2,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            NftCollectionAddress,
                                        > = _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<TokenId> = _serde::__private::None;
                                        let mut __field2: _serde::__private::Option<
                                            Option<String>,
                                        > = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "nft_collection_address",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            NftCollectionAddress,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "token_id",
                                                            ),
                                                        );
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            TokenId,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field2 => {
                                                    if _serde::__private::Option::is_some(&__field2) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "additional_info",
                                                            ),
                                                        );
                                                    }
                                                    __field2 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Option<String>,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "nft_collection_address",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("token_id") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field2 = match __field2 {
                                            _serde::__private::Some(__field2) => __field2,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "additional_info",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(ExecuteMsg::CancelSale {
                                            nft_collection_address: __field0,
                                            token_id: __field1,
                                            additional_info: __field2,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[
                                    "nft_collection_address",
                                    "token_id",
                                    "additional_info",
                                ];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<ExecuteMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field6, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 1",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "sale_info" => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"sale_info" => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<ExecuteMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = ExecuteMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant ExecuteMsg::UpdateSale",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            NftSale,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant ExecuteMsg::UpdateSale with 1 element",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(ExecuteMsg::UpdateSale {
                                            sale_info: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<NftSale> = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "sale_info",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            NftSale,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("sale_info") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(ExecuteMsg::UpdateSale {
                                            sale_info: __field0,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["sale_info"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<ExecuteMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field7, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __field2,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            2u64 => _serde::__private::Ok(__Field::__field2),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 3",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            "token_id" => _serde::__private::Ok(__Field::__field1),
                                            "additional_info" => {
                                                _serde::__private::Ok(__Field::__field2)
                                            }
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            b"token_id" => _serde::__private::Ok(__Field::__field1),
                                            b"additional_info" => {
                                                _serde::__private::Ok(__Field::__field2)
                                            }
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<ExecuteMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = ExecuteMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant ExecuteMsg::BuyNft",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            NftCollectionAddress,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant ExecuteMsg::BuyNft with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                                            TokenId,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        1usize,
                                                        &"struct variant ExecuteMsg::BuyNft with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                                            Option<String>,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        2usize,
                                                        &"struct variant ExecuteMsg::BuyNft with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(ExecuteMsg::BuyNft {
                                            nft_collection_address: __field0,
                                            token_id: __field1,
                                            additional_info: __field2,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            NftCollectionAddress,
                                        > = _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<TokenId> = _serde::__private::None;
                                        let mut __field2: _serde::__private::Option<
                                            Option<String>,
                                        > = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "nft_collection_address",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            NftCollectionAddress,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "token_id",
                                                            ),
                                                        );
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            TokenId,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field2 => {
                                                    if _serde::__private::Option::is_some(&__field2) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "additional_info",
                                                            ),
                                                        );
                                                    }
                                                    __field2 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Option<String>,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "nft_collection_address",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("token_id") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field2 = match __field2 {
                                            _serde::__private::Some(__field2) => __field2,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "additional_info",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(ExecuteMsg::BuyNft {
                                            nft_collection_address: __field0,
                                            token_id: __field1,
                                            additional_info: __field2,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[
                                    "nft_collection_address",
                                    "token_id",
                                    "additional_info",
                                ];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<ExecuteMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field8, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 1",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "offer" => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"offer" => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<ExecuteMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = ExecuteMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant ExecuteMsg::Offer",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            NftOffer,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant ExecuteMsg::Offer with 1 element",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(ExecuteMsg::Offer {
                                            offer: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<NftOffer> = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field("offer"),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            NftOffer,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("offer") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(ExecuteMsg::Offer {
                                            offer: __field0,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["offer"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<ExecuteMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field9, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __field2,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            2u64 => _serde::__private::Ok(__Field::__field2),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 3",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            "token_id" => _serde::__private::Ok(__Field::__field1),
                                            "additional_info" => {
                                                _serde::__private::Ok(__Field::__field2)
                                            }
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            b"token_id" => _serde::__private::Ok(__Field::__field1),
                                            b"additional_info" => {
                                                _serde::__private::Ok(__Field::__field2)
                                            }
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<ExecuteMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = ExecuteMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant ExecuteMsg::CancelOffer",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            NftCollectionAddress,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant ExecuteMsg::CancelOffer with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                                            TokenId,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        1usize,
                                                        &"struct variant ExecuteMsg::CancelOffer with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                                            Option<String>,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        2usize,
                                                        &"struct variant ExecuteMsg::CancelOffer with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(ExecuteMsg::CancelOffer {
                                            nft_collection_address: __field0,
                                            token_id: __field1,
                                            additional_info: __field2,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            NftCollectionAddress,
                                        > = _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<TokenId> = _serde::__private::None;
                                        let mut __field2: _serde::__private::Option<
                                            Option<String>,
                                        > = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "nft_collection_address",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            NftCollectionAddress,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "token_id",
                                                            ),
                                                        );
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            TokenId,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field2 => {
                                                    if _serde::__private::Option::is_some(&__field2) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "additional_info",
                                                            ),
                                                        );
                                                    }
                                                    __field2 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Option<String>,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "nft_collection_address",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("token_id") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field2 = match __field2 {
                                            _serde::__private::Some(__field2) => __field2,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "additional_info",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(ExecuteMsg::CancelOffer {
                                            nft_collection_address: __field0,
                                            token_id: __field1,
                                            additional_info: __field2,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[
                                    "nft_collection_address",
                                    "token_id",
                                    "additional_info",
                                ];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<ExecuteMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field10, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __field2,
                                    __field3,
                                    __field4,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            2u64 => _serde::__private::Ok(__Field::__field2),
                                            3u64 => _serde::__private::Ok(__Field::__field3),
                                            4u64 => _serde::__private::Ok(__Field::__field4),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 5",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            "token_id" => _serde::__private::Ok(__Field::__field1),
                                            "from" => _serde::__private::Ok(__Field::__field2),
                                            "if_accepted" => _serde::__private::Ok(__Field::__field3),
                                            "answer_msg" => _serde::__private::Ok(__Field::__field4),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            b"token_id" => _serde::__private::Ok(__Field::__field1),
                                            b"from" => _serde::__private::Ok(__Field::__field2),
                                            b"if_accepted" => _serde::__private::Ok(__Field::__field3),
                                            b"answer_msg" => _serde::__private::Ok(__Field::__field4),
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<ExecuteMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = ExecuteMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant ExecuteMsg::AnswerOffer",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            NftCollectionAddress,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant ExecuteMsg::AnswerOffer with 5 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                                            TokenId,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        1usize,
                                                        &"struct variant ExecuteMsg::AnswerOffer with 5 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                                            String,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        2usize,
                                                        &"struct variant ExecuteMsg::AnswerOffer with 5 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field3 = match match _serde::de::SeqAccess::next_element::<
                                            bool,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        3usize,
                                                        &"struct variant ExecuteMsg::AnswerOffer with 5 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field4 = match match _serde::de::SeqAccess::next_element::<
                                            Option<String>,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        4usize,
                                                        &"struct variant ExecuteMsg::AnswerOffer with 5 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(ExecuteMsg::AnswerOffer {
                                            nft_collection_address: __field0,
                                            token_id: __field1,
                                            from: __field2,
                                            if_accepted: __field3,
                                            answer_msg: __field4,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            NftCollectionAddress,
                                        > = _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<TokenId> = _serde::__private::None;
                                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                                        let mut __field3: _serde::__private::Option<bool> = _serde::__private::None;
                                        let mut __field4: _serde::__private::Option<
                                            Option<String>,
                                        > = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "nft_collection_address",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            NftCollectionAddress,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "token_id",
                                                            ),
                                                        );
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            TokenId,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field2 => {
                                                    if _serde::__private::Option::is_some(&__field2) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field("from"),
                                                        );
                                                    }
                                                    __field2 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            String,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field3 => {
                                                    if _serde::__private::Option::is_some(&__field3) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "if_accepted",
                                                            ),
                                                        );
                                                    }
                                                    __field3 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            bool,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field4 => {
                                                    if _serde::__private::Option::is_some(&__field4) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "answer_msg",
                                                            ),
                                                        );
                                                    }
                                                    __field4 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Option<String>,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "nft_collection_address",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("token_id") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field2 = match __field2 {
                                            _serde::__private::Some(__field2) => __field2,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("from") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field3 = match __field3 {
                                            _serde::__private::Some(__field3) => __field3,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("if_accepted") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field4 = match __field4 {
                                            _serde::__private::Some(__field4) => __field4,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("answer_msg") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(ExecuteMsg::AnswerOffer {
                                            nft_collection_address: __field0,
                                            token_id: __field1,
                                            from: __field2,
                                            if_accepted: __field3,
                                            answer_msg: __field4,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[
                                    "nft_collection_address",
                                    "token_id",
                                    "from",
                                    "if_accepted",
                                    "answer_msg",
                                ];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<ExecuteMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field11, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 1",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "additional_info" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"additional_info" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<ExecuteMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = ExecuteMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant ExecuteMsg::CreateMyProfile",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            Option<String>,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant ExecuteMsg::CreateMyProfile with 1 element",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(ExecuteMsg::CreateMyProfile {
                                            additional_info: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            Option<String>,
                                        > = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "additional_info",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Option<String>,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "additional_info",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(ExecuteMsg::CreateMyProfile {
                                            additional_info: __field0,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[
                                    "additional_info",
                                ];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<ExecuteMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field12, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 2",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "profile" => _serde::__private::Ok(__Field::__field0),
                                            "profile_update_action" => {
                                                _serde::__private::Ok(__Field::__field1)
                                            }
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"profile" => _serde::__private::Ok(__Field::__field0),
                                            b"profile_update_action" => {
                                                _serde::__private::Ok(__Field::__field1)
                                            }
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<ExecuteMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = ExecuteMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant ExecuteMsg::UpdateMyProfile",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            Profile,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant ExecuteMsg::UpdateMyProfile with 2 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                                            ProfileUpdateAction,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        1usize,
                                                        &"struct variant ExecuteMsg::UpdateMyProfile with 2 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(ExecuteMsg::UpdateMyProfile {
                                            profile: __field0,
                                            profile_update_action: __field1,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<Profile> = _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<
                                            ProfileUpdateAction,
                                        > = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "profile",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Profile,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "profile_update_action",
                                                            ),
                                                        );
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            ProfileUpdateAction,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("profile") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "profile_update_action",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(ExecuteMsg::UpdateMyProfile {
                                            profile: __field0,
                                            profile_update_action: __field1,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[
                                    "profile",
                                    "profile_update_action",
                                ];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<ExecuteMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field13, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 2",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "to" => _serde::__private::Ok(__Field::__field0),
                                            "message" => _serde::__private::Ok(__Field::__field1),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"to" => _serde::__private::Ok(__Field::__field0),
                                            b"message" => _serde::__private::Ok(__Field::__field1),
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<ExecuteMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = ExecuteMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant ExecuteMsg::SendMessage",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            String,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant ExecuteMsg::SendMessage with 2 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                                            String,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        1usize,
                                                        &"struct variant ExecuteMsg::SendMessage with 2 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(ExecuteMsg::SendMessage {
                                            to: __field0,
                                            message: __field1,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field("to"),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            String,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "message",
                                                            ),
                                                        );
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            String,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("to") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("message") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(ExecuteMsg::SendMessage {
                                            to: __field0,
                                            message: __field1,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["to", "message"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<ExecuteMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field14, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        Cw20ReceiveMsg,
                                    >(__variant),
                                    ExecuteMsg::Receive,
                                )
                            }
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &[
                    "update_config",
                    "claim_marketplace_fees",
                    "add_new_collection",
                    "transfer_my_nft",
                    "sell_nft",
                    "cancel_sale",
                    "update_sale",
                    "buy_nft",
                    "offer",
                    "cancel_offer",
                    "answer_offer",
                    "create_my_profile",
                    "update_my_profile",
                    "send_message",
                    "receive",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "ExecuteMsg",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ExecuteMsg>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[allow(clippy::large_enum_variant)]
    impl ::core::clone::Clone for ExecuteMsg {
        #[inline]
        fn clone(&self) -> ExecuteMsg {
            match self {
                ExecuteMsg::UpdateConfig { list_of_updates: __self_0 } => {
                    ExecuteMsg::UpdateConfig {
                        list_of_updates: ::core::clone::Clone::clone(__self_0),
                    }
                }
                ExecuteMsg::ClaimMarketplaceFees {} => {
                    ExecuteMsg::ClaimMarketplaceFees {
                    }
                }
                ExecuteMsg::AddNewCollection {
                    nft_collection_address: __self_0,
                    nft_contract_type: __self_1,
                } => {
                    ExecuteMsg::AddNewCollection {
                        nft_collection_address: ::core::clone::Clone::clone(__self_0),
                        nft_contract_type: ::core::clone::Clone::clone(__self_1),
                    }
                }
                ExecuteMsg::TransferMyNft {
                    nft_collection_address: __self_0,
                    token_id: __self_1,
                    recipient: __self_2,
                } => {
                    ExecuteMsg::TransferMyNft {
                        nft_collection_address: ::core::clone::Clone::clone(__self_0),
                        token_id: ::core::clone::Clone::clone(__self_1),
                        recipient: ::core::clone::Clone::clone(__self_2),
                    }
                }
                ExecuteMsg::SellNft { sale_info: __self_0 } => {
                    ExecuteMsg::SellNft {
                        sale_info: ::core::clone::Clone::clone(__self_0),
                    }
                }
                ExecuteMsg::CancelSale {
                    nft_collection_address: __self_0,
                    token_id: __self_1,
                    additional_info: __self_2,
                } => {
                    ExecuteMsg::CancelSale {
                        nft_collection_address: ::core::clone::Clone::clone(__self_0),
                        token_id: ::core::clone::Clone::clone(__self_1),
                        additional_info: ::core::clone::Clone::clone(__self_2),
                    }
                }
                ExecuteMsg::UpdateSale { sale_info: __self_0 } => {
                    ExecuteMsg::UpdateSale {
                        sale_info: ::core::clone::Clone::clone(__self_0),
                    }
                }
                ExecuteMsg::BuyNft {
                    nft_collection_address: __self_0,
                    token_id: __self_1,
                    additional_info: __self_2,
                } => {
                    ExecuteMsg::BuyNft {
                        nft_collection_address: ::core::clone::Clone::clone(__self_0),
                        token_id: ::core::clone::Clone::clone(__self_1),
                        additional_info: ::core::clone::Clone::clone(__self_2),
                    }
                }
                ExecuteMsg::Offer { offer: __self_0 } => {
                    ExecuteMsg::Offer {
                        offer: ::core::clone::Clone::clone(__self_0),
                    }
                }
                ExecuteMsg::CancelOffer {
                    nft_collection_address: __self_0,
                    token_id: __self_1,
                    additional_info: __self_2,
                } => {
                    ExecuteMsg::CancelOffer {
                        nft_collection_address: ::core::clone::Clone::clone(__self_0),
                        token_id: ::core::clone::Clone::clone(__self_1),
                        additional_info: ::core::clone::Clone::clone(__self_2),
                    }
                }
                ExecuteMsg::AnswerOffer {
                    nft_collection_address: __self_0,
                    token_id: __self_1,
                    from: __self_2,
                    if_accepted: __self_3,
                    answer_msg: __self_4,
                } => {
                    ExecuteMsg::AnswerOffer {
                        nft_collection_address: ::core::clone::Clone::clone(__self_0),
                        token_id: ::core::clone::Clone::clone(__self_1),
                        from: ::core::clone::Clone::clone(__self_2),
                        if_accepted: ::core::clone::Clone::clone(__self_3),
                        answer_msg: ::core::clone::Clone::clone(__self_4),
                    }
                }
                ExecuteMsg::CreateMyProfile { additional_info: __self_0 } => {
                    ExecuteMsg::CreateMyProfile {
                        additional_info: ::core::clone::Clone::clone(__self_0),
                    }
                }
                ExecuteMsg::UpdateMyProfile {
                    profile: __self_0,
                    profile_update_action: __self_1,
                } => {
                    ExecuteMsg::UpdateMyProfile {
                        profile: ::core::clone::Clone::clone(__self_0),
                        profile_update_action: ::core::clone::Clone::clone(__self_1),
                    }
                }
                ExecuteMsg::SendMessage { to: __self_0, message: __self_1 } => {
                    ExecuteMsg::SendMessage {
                        to: ::core::clone::Clone::clone(__self_0),
                        message: ::core::clone::Clone::clone(__self_1),
                    }
                }
                ExecuteMsg::Receive(__self_0) => {
                    ExecuteMsg::Receive(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[allow(clippy::large_enum_variant)]
    impl ::core::fmt::Debug for ExecuteMsg {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ExecuteMsg::UpdateConfig { list_of_updates: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "UpdateConfig",
                        "list_of_updates",
                        &__self_0,
                    )
                }
                ExecuteMsg::ClaimMarketplaceFees {} => {
                    ::core::fmt::Formatter::write_str(f, "ClaimMarketplaceFees")
                }
                ExecuteMsg::AddNewCollection {
                    nft_collection_address: __self_0,
                    nft_contract_type: __self_1,
                } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "AddNewCollection",
                        "nft_collection_address",
                        __self_0,
                        "nft_contract_type",
                        &__self_1,
                    )
                }
                ExecuteMsg::TransferMyNft {
                    nft_collection_address: __self_0,
                    token_id: __self_1,
                    recipient: __self_2,
                } => {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "TransferMyNft",
                        "nft_collection_address",
                        __self_0,
                        "token_id",
                        __self_1,
                        "recipient",
                        &__self_2,
                    )
                }
                ExecuteMsg::SellNft { sale_info: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "SellNft",
                        "sale_info",
                        &__self_0,
                    )
                }
                ExecuteMsg::CancelSale {
                    nft_collection_address: __self_0,
                    token_id: __self_1,
                    additional_info: __self_2,
                } => {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "CancelSale",
                        "nft_collection_address",
                        __self_0,
                        "token_id",
                        __self_1,
                        "additional_info",
                        &__self_2,
                    )
                }
                ExecuteMsg::UpdateSale { sale_info: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "UpdateSale",
                        "sale_info",
                        &__self_0,
                    )
                }
                ExecuteMsg::BuyNft {
                    nft_collection_address: __self_0,
                    token_id: __self_1,
                    additional_info: __self_2,
                } => {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "BuyNft",
                        "nft_collection_address",
                        __self_0,
                        "token_id",
                        __self_1,
                        "additional_info",
                        &__self_2,
                    )
                }
                ExecuteMsg::Offer { offer: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Offer",
                        "offer",
                        &__self_0,
                    )
                }
                ExecuteMsg::CancelOffer {
                    nft_collection_address: __self_0,
                    token_id: __self_1,
                    additional_info: __self_2,
                } => {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "CancelOffer",
                        "nft_collection_address",
                        __self_0,
                        "token_id",
                        __self_1,
                        "additional_info",
                        &__self_2,
                    )
                }
                ExecuteMsg::AnswerOffer {
                    nft_collection_address: __self_0,
                    token_id: __self_1,
                    from: __self_2,
                    if_accepted: __self_3,
                    answer_msg: __self_4,
                } => {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "AnswerOffer",
                        "nft_collection_address",
                        __self_0,
                        "token_id",
                        __self_1,
                        "from",
                        __self_2,
                        "if_accepted",
                        __self_3,
                        "answer_msg",
                        &__self_4,
                    )
                }
                ExecuteMsg::CreateMyProfile { additional_info: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "CreateMyProfile",
                        "additional_info",
                        &__self_0,
                    )
                }
                ExecuteMsg::UpdateMyProfile {
                    profile: __self_0,
                    profile_update_action: __self_1,
                } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "UpdateMyProfile",
                        "profile",
                        __self_0,
                        "profile_update_action",
                        &__self_1,
                    )
                }
                ExecuteMsg::SendMessage { to: __self_0, message: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "SendMessage",
                        "to",
                        __self_0,
                        "message",
                        &__self_1,
                    )
                }
                ExecuteMsg::Receive(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Receive",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[allow(clippy::large_enum_variant)]
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ExecuteMsg {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[allow(clippy::large_enum_variant)]
    impl ::core::cmp::PartialEq for ExecuteMsg {
        #[inline]
        fn eq(&self, other: &ExecuteMsg) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        ExecuteMsg::UpdateConfig { list_of_updates: __self_0 },
                        ExecuteMsg::UpdateConfig { list_of_updates: __arg1_0 },
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExecuteMsg::AddNewCollection {
                            nft_collection_address: __self_0,
                            nft_contract_type: __self_1,
                        },
                        ExecuteMsg::AddNewCollection {
                            nft_collection_address: __arg1_0,
                            nft_contract_type: __arg1_1,
                        },
                    ) => *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,
                    (
                        ExecuteMsg::TransferMyNft {
                            nft_collection_address: __self_0,
                            token_id: __self_1,
                            recipient: __self_2,
                        },
                        ExecuteMsg::TransferMyNft {
                            nft_collection_address: __arg1_0,
                            token_id: __arg1_1,
                            recipient: __arg1_2,
                        },
                    ) => {
                        *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1
                            && *__self_2 == *__arg1_2
                    }
                    (
                        ExecuteMsg::SellNft { sale_info: __self_0 },
                        ExecuteMsg::SellNft { sale_info: __arg1_0 },
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExecuteMsg::CancelSale {
                            nft_collection_address: __self_0,
                            token_id: __self_1,
                            additional_info: __self_2,
                        },
                        ExecuteMsg::CancelSale {
                            nft_collection_address: __arg1_0,
                            token_id: __arg1_1,
                            additional_info: __arg1_2,
                        },
                    ) => {
                        *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1
                            && *__self_2 == *__arg1_2
                    }
                    (
                        ExecuteMsg::UpdateSale { sale_info: __self_0 },
                        ExecuteMsg::UpdateSale { sale_info: __arg1_0 },
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExecuteMsg::BuyNft {
                            nft_collection_address: __self_0,
                            token_id: __self_1,
                            additional_info: __self_2,
                        },
                        ExecuteMsg::BuyNft {
                            nft_collection_address: __arg1_0,
                            token_id: __arg1_1,
                            additional_info: __arg1_2,
                        },
                    ) => {
                        *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1
                            && *__self_2 == *__arg1_2
                    }
                    (
                        ExecuteMsg::Offer { offer: __self_0 },
                        ExecuteMsg::Offer { offer: __arg1_0 },
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExecuteMsg::CancelOffer {
                            nft_collection_address: __self_0,
                            token_id: __self_1,
                            additional_info: __self_2,
                        },
                        ExecuteMsg::CancelOffer {
                            nft_collection_address: __arg1_0,
                            token_id: __arg1_1,
                            additional_info: __arg1_2,
                        },
                    ) => {
                        *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1
                            && *__self_2 == *__arg1_2
                    }
                    (
                        ExecuteMsg::AnswerOffer {
                            nft_collection_address: __self_0,
                            token_id: __self_1,
                            from: __self_2,
                            if_accepted: __self_3,
                            answer_msg: __self_4,
                        },
                        ExecuteMsg::AnswerOffer {
                            nft_collection_address: __arg1_0,
                            token_id: __arg1_1,
                            from: __arg1_2,
                            if_accepted: __arg1_3,
                            answer_msg: __arg1_4,
                        },
                    ) => {
                        *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1
                            && *__self_2 == *__arg1_2 && *__self_3 == *__arg1_3
                            && *__self_4 == *__arg1_4
                    }
                    (
                        ExecuteMsg::CreateMyProfile { additional_info: __self_0 },
                        ExecuteMsg::CreateMyProfile { additional_info: __arg1_0 },
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExecuteMsg::UpdateMyProfile {
                            profile: __self_0,
                            profile_update_action: __self_1,
                        },
                        ExecuteMsg::UpdateMyProfile {
                            profile: __arg1_0,
                            profile_update_action: __arg1_1,
                        },
                    ) => *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,
                    (
                        ExecuteMsg::SendMessage { to: __self_0, message: __self_1 },
                        ExecuteMsg::SendMessage { to: __arg1_0, message: __arg1_1 },
                    ) => *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,
                    (ExecuteMsg::Receive(__self_0), ExecuteMsg::Receive(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    _ => true,
                }
        }
    }
    const _: () = {
        use ::cosmwasm_schema::schemars as schemars;
        #[automatically_derived]
        #[allow(unused_braces)]
        impl schemars::JsonSchema for ExecuteMsg {
            fn schema_name() -> std::string::String {
                "ExecuteMsg".to_owned()
            }
            fn json_schema(
                gen: &mut schemars::gen::SchemaGenerator,
            ) -> schemars::schema::Schema {
                schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                    subschemas: Some(
                        Box::new(schemars::schema::SubschemaValidation {
                            one_of: Some(
                                <[_]>::into_vec(
                                    #[rustc_box]
                                    ::alloc::boxed::Box::new([
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "update_config".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "list_of_updates".to_owned(),
                                                                                gen.subschema_for::<Vec<UpdateConfigEnum>>(),
                                                                            );
                                                                        if !<Vec<
                                                                            UpdateConfigEnum,
                                                                        > as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("list_of_updates".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("update_config".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "claim_marketplace_fees".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("claim_marketplace_fees".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "add_new_collection".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "nft_collection_address".to_owned(),
                                                                                gen.subschema_for::<NftCollectionAddress>(),
                                                                            );
                                                                        if !<NftCollectionAddress as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("nft_collection_address".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "nft_contract_type".to_owned(),
                                                                                gen.subschema_for::<NftContractType>(),
                                                                            );
                                                                        if !<NftContractType as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("nft_contract_type".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("add_new_collection".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "transfer_my_nft".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "nft_collection_address".to_owned(),
                                                                                gen.subschema_for::<NftCollectionAddress>(),
                                                                            );
                                                                        if !<NftCollectionAddress as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("nft_collection_address".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "token_id".to_owned(),
                                                                                gen.subschema_for::<TokenId>(),
                                                                            );
                                                                        if !<TokenId as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation.required.insert("token_id".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "recipient".to_owned(),
                                                                                gen.subschema_for::<String>(),
                                                                            );
                                                                        if !<String as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation.required.insert("recipient".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("transfer_my_nft".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "sell_nft".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "sale_info".to_owned(),
                                                                                gen.subschema_for::<NftSale>(),
                                                                            );
                                                                        if !<NftSale as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation.required.insert("sale_info".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("sell_nft".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "cancel_sale".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "nft_collection_address".to_owned(),
                                                                                gen.subschema_for::<NftCollectionAddress>(),
                                                                            );
                                                                        if !<NftCollectionAddress as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("nft_collection_address".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "token_id".to_owned(),
                                                                                gen.subschema_for::<TokenId>(),
                                                                            );
                                                                        if !<TokenId as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation.required.insert("token_id".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "additional_info".to_owned(),
                                                                                gen.subschema_for::<Option<String>>(),
                                                                            );
                                                                        if !<Option<
                                                                            String,
                                                                        > as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("additional_info".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("cancel_sale".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "update_sale".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "sale_info".to_owned(),
                                                                                gen.subschema_for::<NftSale>(),
                                                                            );
                                                                        if !<NftSale as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation.required.insert("sale_info".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("update_sale".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "buy_nft".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "nft_collection_address".to_owned(),
                                                                                gen.subschema_for::<NftCollectionAddress>(),
                                                                            );
                                                                        if !<NftCollectionAddress as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("nft_collection_address".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "token_id".to_owned(),
                                                                                gen.subschema_for::<TokenId>(),
                                                                            );
                                                                        if !<TokenId as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation.required.insert("token_id".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "additional_info".to_owned(),
                                                                                gen.subschema_for::<Option<String>>(),
                                                                            );
                                                                        if !<Option<
                                                                            String,
                                                                        > as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("additional_info".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("buy_nft".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "offer".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "offer".to_owned(),
                                                                                gen.subschema_for::<NftOffer>(),
                                                                            );
                                                                        if !<NftOffer as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation.required.insert("offer".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("offer".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "cancel_offer".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "nft_collection_address".to_owned(),
                                                                                gen.subschema_for::<NftCollectionAddress>(),
                                                                            );
                                                                        if !<NftCollectionAddress as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("nft_collection_address".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "token_id".to_owned(),
                                                                                gen.subschema_for::<TokenId>(),
                                                                            );
                                                                        if !<TokenId as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation.required.insert("token_id".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "additional_info".to_owned(),
                                                                                gen.subschema_for::<Option<String>>(),
                                                                            );
                                                                        if !<Option<
                                                                            String,
                                                                        > as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("additional_info".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("cancel_offer".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "answer_offer".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "nft_collection_address".to_owned(),
                                                                                gen.subschema_for::<NftCollectionAddress>(),
                                                                            );
                                                                        if !<NftCollectionAddress as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("nft_collection_address".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "token_id".to_owned(),
                                                                                gen.subschema_for::<TokenId>(),
                                                                            );
                                                                        if !<TokenId as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation.required.insert("token_id".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert("from".to_owned(), gen.subschema_for::<String>());
                                                                        if !<String as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation.required.insert("from".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "if_accepted".to_owned(),
                                                                                gen.subschema_for::<bool>(),
                                                                            );
                                                                        if !<bool as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation.required.insert("if_accepted".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "answer_msg".to_owned(),
                                                                                gen.subschema_for::<Option<String>>(),
                                                                            );
                                                                        if !<Option<
                                                                            String,
                                                                        > as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation.required.insert("answer_msg".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("answer_offer".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "create_my_profile".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "additional_info".to_owned(),
                                                                                gen.subschema_for::<Option<String>>(),
                                                                            );
                                                                        if !<Option<
                                                                            String,
                                                                        > as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("additional_info".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("create_my_profile".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "update_my_profile".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "profile".to_owned(),
                                                                                gen.subschema_for::<Profile>(),
                                                                            );
                                                                        if !<Profile as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation.required.insert("profile".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "profile_update_action".to_owned(),
                                                                                gen.subschema_for::<ProfileUpdateAction>(),
                                                                            );
                                                                        if !<ProfileUpdateAction as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("profile_update_action".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("update_my_profile".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "send_message".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert("to".to_owned(), gen.subschema_for::<String>());
                                                                        if !<String as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation.required.insert("to".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "message".to_owned(),
                                                                                gen.subschema_for::<String>(),
                                                                            );
                                                                        if !<String as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation.required.insert("message".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("send_message".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "receive".to_owned(),
                                                                gen.subschema_for::<Cw20ReceiveMsg>(),
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("receive".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                    ]),
                                ),
                            ),
                            ..Default::default()
                        }),
                    ),
                    ..Default::default()
                })
            }
        }
    };
    impl ExecuteMsg {
        pub fn wasm_execute_message_create_profile(
            contract_address: String,
            additional_info: Option<String>,
        ) -> Result<Option<WasmMsg>, ContractError> {
            Ok(
                Some(WasmMsg::Execute {
                    contract_addr: contract_address,
                    msg: to_binary(
                        &ExecuteMsg::CreateMyProfile {
                            additional_info,
                        },
                    )?,
                    funds: ::alloc::vec::Vec::new(),
                }),
            )
        }
        pub fn wasm_execute_message_cancel_sale(
            nft_collection_address: String,
            contract_address: String,
            token_id: TokenId,
            seller: String,
        ) -> Result<Option<WasmMsg>, ContractError> {
            Ok(
                Some(WasmMsg::Execute {
                    contract_addr: contract_address,
                    msg: to_binary(
                        &ExecuteMsg::CancelSale {
                            nft_collection_address,
                            token_id,
                            additional_info: Some(seller),
                        },
                    )?,
                    funds: ::alloc::vec::Vec::new(),
                }),
            )
        }
        pub fn wasm_execute_message_sell(
            marketplace_listing_fee_value: Uint128,
            contract_address: String,
            sale_info: NftSale,
            marketplace_listing_fee_denom: String,
        ) -> Result<Option<WasmMsg>, ContractError> {
            Ok(
                Some(WasmMsg::Execute {
                    contract_addr: contract_address,
                    msg: to_binary(&ExecuteMsg::SellNft { sale_info })?,
                    funds: coins(
                        marketplace_listing_fee_value.u128(),
                        marketplace_listing_fee_denom,
                    ),
                }),
            )
        }
        pub fn wasm_execute_cancel_offer(
            nft_collection_address: String,
            contract_address: String,
            token_id: TokenId,
            offerer_address: String,
        ) -> Result<Option<WasmMsg>, ContractError> {
            Ok(
                Some(WasmMsg::Execute {
                    contract_addr: contract_address,
                    msg: to_binary(
                        &ExecuteMsg::CancelOffer {
                            nft_collection_address,
                            token_id,
                            additional_info: Some(offerer_address),
                        },
                    )?,
                    funds: ::alloc::vec::Vec::new(),
                }),
            )
        }
        pub fn wasm_execute_buy_nft(
            nft_collection_address: String,
            contract_address: String,
            token_id: TokenId,
            offerer_address: String,
            offer_price_value: Uint128,
            offer_price_denom: String,
        ) -> Result<Option<WasmMsg>, ContractError> {
            Ok(
                Some(WasmMsg::Execute {
                    contract_addr: contract_address,
                    msg: to_binary(
                        &ExecuteMsg::BuyNft {
                            nft_collection_address,
                            token_id,
                            additional_info: Some(offerer_address),
                        },
                    )?,
                    funds: coins(offer_price_value.u128(), offer_price_denom),
                }),
            )
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[serde(
        deny_unknown_fields,
        rename_all = "snake_case",
        crate = "::cosmwasm_schema::serde"
    )]
    #[schemars(crate = "::cosmwasm_schema::schemars")]
    pub enum ReceiveMsg {
        LevelUpProfile {},
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use ::cosmwasm_schema::serde as _serde;
        #[automatically_derived]
        impl ::cosmwasm_schema::serde::Serialize for ReceiveMsg {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> ::cosmwasm_schema::serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: ::cosmwasm_schema::serde::Serializer,
            {
                match *self {
                    ReceiveMsg::LevelUpProfile {} => {
                        let __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "ReceiveMsg",
                            0u32,
                            "level_up_profile",
                            0,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use ::cosmwasm_schema::serde as _serde;
        #[automatically_derived]
        impl<'de> ::cosmwasm_schema::serde::Deserialize<'de> for ReceiveMsg {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> ::cosmwasm_schema::serde::__private::Result<Self, __D::Error>
            where
                __D: ::cosmwasm_schema::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 1",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "level_up_profile" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"level_up_profile" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ReceiveMsg>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ReceiveMsg;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum ReceiveMsg",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {}
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 0",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<ReceiveMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = ReceiveMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant ReceiveMsg::LevelUpProfile",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        _: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        _serde::__private::Ok(ReceiveMsg::LevelUpProfile {})
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        _serde::__private::Option::map(
                                            match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                            |__impossible| match __impossible {},
                                        );
                                        _serde::__private::Ok(ReceiveMsg::LevelUpProfile {})
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<ReceiveMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["level_up_profile"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "ReceiveMsg",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ReceiveMsg>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for ReceiveMsg {
        #[inline]
        fn clone(&self) -> ReceiveMsg {
            ReceiveMsg::LevelUpProfile {}
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::fmt::Debug for ReceiveMsg {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "LevelUpProfile")
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ReceiveMsg {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for ReceiveMsg {
        #[inline]
        fn eq(&self, other: &ReceiveMsg) -> bool {
            true
        }
    }
    const _: () = {
        use ::cosmwasm_schema::schemars as schemars;
        #[automatically_derived]
        #[allow(unused_braces)]
        impl schemars::JsonSchema for ReceiveMsg {
            fn schema_name() -> std::string::String {
                "ReceiveMsg".to_owned()
            }
            fn json_schema(
                gen: &mut schemars::gen::SchemaGenerator,
            ) -> schemars::schema::Schema {
                schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                    subschemas: Some(
                        Box::new(schemars::schema::SubschemaValidation {
                            one_of: Some(
                                <[_]>::into_vec(
                                    #[rustc_box]
                                    ::alloc::boxed::Box::new([
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "level_up_profile".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("level_up_profile".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                    ]),
                                ),
                            ),
                            ..Default::default()
                        }),
                    ),
                    ..Default::default()
                })
            }
        }
    };
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[serde(
        deny_unknown_fields,
        rename_all = "snake_case",
        crate = "::cosmwasm_schema::serde"
    )]
    #[schemars(crate = "::cosmwasm_schema::schemars")]
    pub enum UpdateConfigEnum {
        EnableDisable {},
        AddDenoms { denoms: Vec<Denomination> },
        RemoveDenoms { denoms: Vec<Denomination> },
        UpdateOwner { address: String },
        UpdateRewardSystem { reward_system: RewardSystem },
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use ::cosmwasm_schema::serde as _serde;
        #[automatically_derived]
        impl ::cosmwasm_schema::serde::Serialize for UpdateConfigEnum {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> ::cosmwasm_schema::serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: ::cosmwasm_schema::serde::Serializer,
            {
                match *self {
                    UpdateConfigEnum::EnableDisable {} => {
                        let __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "UpdateConfigEnum",
                            0u32,
                            "enable_disable",
                            0,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    UpdateConfigEnum::AddDenoms { ref denoms } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "UpdateConfigEnum",
                            1u32,
                            "add_denoms",
                            0 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "denoms",
                            denoms,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    UpdateConfigEnum::RemoveDenoms { ref denoms } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "UpdateConfigEnum",
                            2u32,
                            "remove_denoms",
                            0 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "denoms",
                            denoms,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    UpdateConfigEnum::UpdateOwner { ref address } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "UpdateConfigEnum",
                            3u32,
                            "update_owner",
                            0 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "address",
                            address,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    UpdateConfigEnum::UpdateRewardSystem { ref reward_system } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "UpdateConfigEnum",
                            4u32,
                            "update_reward_system",
                            0 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "reward_system",
                            reward_system,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use ::cosmwasm_schema::serde as _serde;
        #[automatically_derived]
        impl<'de> ::cosmwasm_schema::serde::Deserialize<'de> for UpdateConfigEnum {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> ::cosmwasm_schema::serde::__private::Result<Self, __D::Error>
            where
                __D: ::cosmwasm_schema::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 5",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "enable_disable" => _serde::__private::Ok(__Field::__field0),
                            "add_denoms" => _serde::__private::Ok(__Field::__field1),
                            "remove_denoms" => _serde::__private::Ok(__Field::__field2),
                            "update_owner" => _serde::__private::Ok(__Field::__field3),
                            "update_reward_system" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"enable_disable" => _serde::__private::Ok(__Field::__field0),
                            b"add_denoms" => _serde::__private::Ok(__Field::__field1),
                            b"remove_denoms" => _serde::__private::Ok(__Field::__field2),
                            b"update_owner" => _serde::__private::Ok(__Field::__field3),
                            b"update_reward_system" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UpdateConfigEnum>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UpdateConfigEnum;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum UpdateConfigEnum",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {}
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 0",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<UpdateConfigEnum>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = UpdateConfigEnum;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant UpdateConfigEnum::EnableDisable",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        _: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        _serde::__private::Ok(UpdateConfigEnum::EnableDisable {})
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        _serde::__private::Option::map(
                                            match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                            |__impossible| match __impossible {},
                                        );
                                        _serde::__private::Ok(UpdateConfigEnum::EnableDisable {})
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<UpdateConfigEnum>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field1, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 1",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "denoms" => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"denoms" => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<UpdateConfigEnum>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = UpdateConfigEnum;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant UpdateConfigEnum::AddDenoms",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            Vec<Denomination>,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant UpdateConfigEnum::AddDenoms with 1 element",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(UpdateConfigEnum::AddDenoms {
                                            denoms: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            Vec<Denomination>,
                                        > = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field("denoms"),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Vec<Denomination>,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("denoms") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(UpdateConfigEnum::AddDenoms {
                                            denoms: __field0,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["denoms"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<UpdateConfigEnum>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field2, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 1",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "denoms" => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"denoms" => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<UpdateConfigEnum>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = UpdateConfigEnum;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant UpdateConfigEnum::RemoveDenoms",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            Vec<Denomination>,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant UpdateConfigEnum::RemoveDenoms with 1 element",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(UpdateConfigEnum::RemoveDenoms {
                                            denoms: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            Vec<Denomination>,
                                        > = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field("denoms"),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Vec<Denomination>,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("denoms") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(UpdateConfigEnum::RemoveDenoms {
                                            denoms: __field0,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["denoms"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<UpdateConfigEnum>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field3, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 1",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "address" => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"address" => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<UpdateConfigEnum>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = UpdateConfigEnum;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant UpdateConfigEnum::UpdateOwner",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            String,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant UpdateConfigEnum::UpdateOwner with 1 element",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(UpdateConfigEnum::UpdateOwner {
                                            address: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "address",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            String,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("address") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(UpdateConfigEnum::UpdateOwner {
                                            address: __field0,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["address"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<UpdateConfigEnum>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field4, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 1",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "reward_system" => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"reward_system" => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<UpdateConfigEnum>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = UpdateConfigEnum;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant UpdateConfigEnum::UpdateRewardSystem",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            RewardSystem,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant UpdateConfigEnum::UpdateRewardSystem with 1 element",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(UpdateConfigEnum::UpdateRewardSystem {
                                            reward_system: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<RewardSystem> = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "reward_system",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            RewardSystem,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "reward_system",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(UpdateConfigEnum::UpdateRewardSystem {
                                            reward_system: __field0,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["reward_system"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<UpdateConfigEnum>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &[
                    "enable_disable",
                    "add_denoms",
                    "remove_denoms",
                    "update_owner",
                    "update_reward_system",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "UpdateConfigEnum",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UpdateConfigEnum>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for UpdateConfigEnum {
        #[inline]
        fn clone(&self) -> UpdateConfigEnum {
            match self {
                UpdateConfigEnum::EnableDisable {} => UpdateConfigEnum::EnableDisable {},
                UpdateConfigEnum::AddDenoms { denoms: __self_0 } => {
                    UpdateConfigEnum::AddDenoms {
                        denoms: ::core::clone::Clone::clone(__self_0),
                    }
                }
                UpdateConfigEnum::RemoveDenoms { denoms: __self_0 } => {
                    UpdateConfigEnum::RemoveDenoms {
                        denoms: ::core::clone::Clone::clone(__self_0),
                    }
                }
                UpdateConfigEnum::UpdateOwner { address: __self_0 } => {
                    UpdateConfigEnum::UpdateOwner {
                        address: ::core::clone::Clone::clone(__self_0),
                    }
                }
                UpdateConfigEnum::UpdateRewardSystem { reward_system: __self_0 } => {
                    UpdateConfigEnum::UpdateRewardSystem {
                        reward_system: ::core::clone::Clone::clone(__self_0),
                    }
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::fmt::Debug for UpdateConfigEnum {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                UpdateConfigEnum::EnableDisable {} => {
                    ::core::fmt::Formatter::write_str(f, "EnableDisable")
                }
                UpdateConfigEnum::AddDenoms { denoms: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "AddDenoms",
                        "denoms",
                        &__self_0,
                    )
                }
                UpdateConfigEnum::RemoveDenoms { denoms: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "RemoveDenoms",
                        "denoms",
                        &__self_0,
                    )
                }
                UpdateConfigEnum::UpdateOwner { address: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "UpdateOwner",
                        "address",
                        &__self_0,
                    )
                }
                UpdateConfigEnum::UpdateRewardSystem { reward_system: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "UpdateRewardSystem",
                        "reward_system",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UpdateConfigEnum {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for UpdateConfigEnum {
        #[inline]
        fn eq(&self, other: &UpdateConfigEnum) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        UpdateConfigEnum::AddDenoms { denoms: __self_0 },
                        UpdateConfigEnum::AddDenoms { denoms: __arg1_0 },
                    ) => *__self_0 == *__arg1_0,
                    (
                        UpdateConfigEnum::RemoveDenoms { denoms: __self_0 },
                        UpdateConfigEnum::RemoveDenoms { denoms: __arg1_0 },
                    ) => *__self_0 == *__arg1_0,
                    (
                        UpdateConfigEnum::UpdateOwner { address: __self_0 },
                        UpdateConfigEnum::UpdateOwner { address: __arg1_0 },
                    ) => *__self_0 == *__arg1_0,
                    (
                        UpdateConfigEnum::UpdateRewardSystem { reward_system: __self_0 },
                        UpdateConfigEnum::UpdateRewardSystem { reward_system: __arg1_0 },
                    ) => *__self_0 == *__arg1_0,
                    _ => true,
                }
        }
    }
    const _: () = {
        use ::cosmwasm_schema::schemars as schemars;
        #[automatically_derived]
        #[allow(unused_braces)]
        impl schemars::JsonSchema for UpdateConfigEnum {
            fn schema_name() -> std::string::String {
                "UpdateConfigEnum".to_owned()
            }
            fn json_schema(
                gen: &mut schemars::gen::SchemaGenerator,
            ) -> schemars::schema::Schema {
                schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                    subschemas: Some(
                        Box::new(schemars::schema::SubschemaValidation {
                            one_of: Some(
                                <[_]>::into_vec(
                                    #[rustc_box]
                                    ::alloc::boxed::Box::new([
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "enable_disable".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("enable_disable".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "add_denoms".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "denoms".to_owned(),
                                                                                gen.subschema_for::<Vec<Denomination>>(),
                                                                            );
                                                                        if !<Vec<
                                                                            Denomination,
                                                                        > as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation.required.insert("denoms".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("add_denoms".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "remove_denoms".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "denoms".to_owned(),
                                                                                gen.subschema_for::<Vec<Denomination>>(),
                                                                            );
                                                                        if !<Vec<
                                                                            Denomination,
                                                                        > as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation.required.insert("denoms".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("remove_denoms".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "update_owner".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "address".to_owned(),
                                                                                gen.subschema_for::<String>(),
                                                                            );
                                                                        if !<String as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation.required.insert("address".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("update_owner".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "update_reward_system".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "reward_system".to_owned(),
                                                                                gen.subschema_for::<RewardSystem>(),
                                                                            );
                                                                        if !<RewardSystem as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("reward_system".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("update_reward_system".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                    ]),
                                ),
                            ),
                            ..Default::default()
                        }),
                    ),
                    ..Default::default()
                })
            }
        }
    };
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[serde(deny_unknown_fields, crate = "::cosmwasm_schema::serde")]
    #[schemars(crate = "::cosmwasm_schema::schemars")]
    pub struct MigrateMsg {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use ::cosmwasm_schema::serde as _serde;
        #[automatically_derived]
        impl ::cosmwasm_schema::serde::Serialize for MigrateMsg {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> ::cosmwasm_schema::serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: ::cosmwasm_schema::serde::Serializer,
            {
                let __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "MigrateMsg",
                    false as usize,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use ::cosmwasm_schema::serde as _serde;
        #[automatically_derived]
        impl<'de> ::cosmwasm_schema::serde::Deserialize<'de> for MigrateMsg {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> ::cosmwasm_schema::serde::__private::Result<Self, __D::Error>
            where
                __D: ::cosmwasm_schema::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {}
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"field index 0 <= i < 0",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                )
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<MigrateMsg>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = MigrateMsg;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct MigrateMsg",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::__private::Ok(MigrateMsg {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        _serde::__private::Option::map(
                            match _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            },
                            |__impossible| match __impossible {},
                        );
                        _serde::__private::Ok(MigrateMsg {})
                    }
                }
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "MigrateMsg",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<MigrateMsg>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for MigrateMsg {
        #[inline]
        fn clone(&self) -> MigrateMsg {
            MigrateMsg {}
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::fmt::Debug for MigrateMsg {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "MigrateMsg")
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for MigrateMsg {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for MigrateMsg {
        #[inline]
        fn eq(&self, other: &MigrateMsg) -> bool {
            true
        }
    }
    const _: () = {
        use ::cosmwasm_schema::schemars as schemars;
        #[automatically_derived]
        #[allow(unused_braces)]
        impl schemars::JsonSchema for MigrateMsg {
            fn schema_name() -> std::string::String {
                "MigrateMsg".to_owned()
            }
            fn json_schema(
                gen: &mut schemars::gen::SchemaGenerator,
            ) -> schemars::schema::Schema {
                {
                    let mut schema_object = schemars::schema::SchemaObject {
                        instance_type: Some(
                            schemars::schema::InstanceType::Object.into(),
                        ),
                        ..Default::default()
                    };
                    let object_validation = schema_object.object();
                    object_validation
                        .additional_properties = Some(Box::new(false.into()));
                    schemars::schema::Schema::Object(schema_object)
                }
            }
        }
    };
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[serde(
        deny_unknown_fields,
        rename_all = "snake_case",
        crate = "::cosmwasm_schema::serde"
    )]
    #[schemars(crate = "::cosmwasm_schema::schemars")]
    pub enum QueryMsg {
        #[returns(nft_marketplace_utils::config::ConfigRewardGenStatsMsg)]
        GetConfig {},
        #[returns(Uint128)]
        GetMarketplaceVolume {},
        #[returns(Uint128)]
        GetNftCollectionVolume { nft_collection_address: NftCollectionAddress },
        #[returns(NftContractType)]
        GetNftCollectionType { nft_collection_address: NftCollectionAddress },
        #[returns(nft_marketplace_utils::nft_collection::NftCollectionInfoByDenom)]
        GetNftCollectionInfo { nft_collection_address: NftCollectionAddress },
        #[returns(nft_marketplace_utils::nft_sale::NftSale)]
        GetNftForSaleInfo {
            nft_collection_address: NftCollectionAddress,
            token_id: TokenId,
        },
        #[returns(Vec<nft_marketplace_utils::nft_sale::NftSale>)]
        GetSellerAllNftsForSale {
            seller_address: String,
            start_after_collection_token_id: Option<NftCollectionAddressTokenId>,
            output_length: Option<u32>,
        },
        #[returns(Vec<nft_marketplace_utils::nft_sale::NftSale>)]
        GetAllTokensByCollAndIfForSale {
            address: String,
            nft_collection_address: NftCollectionAddress,
            output_length: Option<u32>,
        },
        #[returns(Vec<nft_marketplace_utils::nft_sale::NftSale>)]
        GetCollectionAllNftsForSale {
            nft_collection_address: NftCollectionAddress,
            start_after_token_id: Option<TokenId>,
            output_length: Option<u32>,
        },
        #[returns(
            Vec<nft_marketplace_utils::marketplace_statistics::MarketplaceStatsByDenom>
        )]
        GetMarketplaceInfo {},
        #[returns(Vec<nft_marketplace_utils::nft_sale::TokenSaleHistory>)]
        GetTokenIdSaleHistory {
            token_id: TokenId,
            nft_collection_address: NftCollectionAddress,
        },
        #[returns(nft_marketplace_utils::profile::Profile)]
        GetProfileInfo { address_or_username: String },
        #[returns(nft_marketplace_utils::nft_offer::NftOffer)]
        GetAllOffersTokenId {
            token_id: TokenId,
            nft_collection_address: NftCollectionAddress,
            start_after: Option<(NftCollectionAddress, TokenId)>,
            output_length: Option<u32>,
        },
        #[returns(Vec<nft_marketplace_utils::nft_offer::NftOffer>)]
        GetAllOffersAddress {
            address: String,
            start_after: Option<(NftCollectionAddress, TokenId)>,
            output_length: Option<u32>,
        },
        #[returns(Vec<nft_marketplace_utils::nft_collection::NftCollectionAddress>)]
        GetTokenIdsByCollection {
            address: String,
            list_of_collections: Vec<NftCollectionAddress>,
        },
    }
    #[automatically_derived]
    #[cfg(not(target_arch = "wasm32"))]
    impl ::cosmwasm_schema::QueryResponses for QueryMsg {
        fn response_schemas_impl() -> ::std::collections::BTreeMap<
            String,
            ::cosmwasm_schema::schemars::schema::RootSchema,
        > {
            ::std::collections::BTreeMap::from([
                (
                    "get_config".to_string(),
                    ::cosmwasm_schema::schemars::gen::SchemaGenerator::new(
                            ::cosmwasm_schema::schemars::gen::SchemaSettings::draft07(),
                        )
                        .into_root_schema_for::<
                            nft_marketplace_utils::config::ConfigRewardGenStatsMsg,
                        >(),
                ),
                (
                    "get_marketplace_volume".to_string(),
                    ::cosmwasm_schema::schemars::gen::SchemaGenerator::new(
                            ::cosmwasm_schema::schemars::gen::SchemaSettings::draft07(),
                        )
                        .into_root_schema_for::<Uint128>(),
                ),
                (
                    "get_nft_collection_volume".to_string(),
                    ::cosmwasm_schema::schemars::gen::SchemaGenerator::new(
                            ::cosmwasm_schema::schemars::gen::SchemaSettings::draft07(),
                        )
                        .into_root_schema_for::<Uint128>(),
                ),
                (
                    "get_nft_collection_type".to_string(),
                    ::cosmwasm_schema::schemars::gen::SchemaGenerator::new(
                            ::cosmwasm_schema::schemars::gen::SchemaSettings::draft07(),
                        )
                        .into_root_schema_for::<NftContractType>(),
                ),
                (
                    "get_nft_collection_info".to_string(),
                    ::cosmwasm_schema::schemars::gen::SchemaGenerator::new(
                            ::cosmwasm_schema::schemars::gen::SchemaSettings::draft07(),
                        )
                        .into_root_schema_for::<
                            nft_marketplace_utils::nft_collection::NftCollectionInfoByDenom,
                        >(),
                ),
                (
                    "get_nft_for_sale_info".to_string(),
                    ::cosmwasm_schema::schemars::gen::SchemaGenerator::new(
                            ::cosmwasm_schema::schemars::gen::SchemaSettings::draft07(),
                        )
                        .into_root_schema_for::<
                            nft_marketplace_utils::nft_sale::NftSale,
                        >(),
                ),
                (
                    "get_seller_all_nfts_for_sale".to_string(),
                    ::cosmwasm_schema::schemars::gen::SchemaGenerator::new(
                            ::cosmwasm_schema::schemars::gen::SchemaSettings::draft07(),
                        )
                        .into_root_schema_for::<
                            Vec<nft_marketplace_utils::nft_sale::NftSale>,
                        >(),
                ),
                (
                    "get_all_tokens_by_coll_and_if_for_sale".to_string(),
                    ::cosmwasm_schema::schemars::gen::SchemaGenerator::new(
                            ::cosmwasm_schema::schemars::gen::SchemaSettings::draft07(),
                        )
                        .into_root_schema_for::<
                            Vec<nft_marketplace_utils::nft_sale::NftSale>,
                        >(),
                ),
                (
                    "get_collection_all_nfts_for_sale".to_string(),
                    ::cosmwasm_schema::schemars::gen::SchemaGenerator::new(
                            ::cosmwasm_schema::schemars::gen::SchemaSettings::draft07(),
                        )
                        .into_root_schema_for::<
                            Vec<nft_marketplace_utils::nft_sale::NftSale>,
                        >(),
                ),
                (
                    "get_marketplace_info".to_string(),
                    ::cosmwasm_schema::schemars::gen::SchemaGenerator::new(
                            ::cosmwasm_schema::schemars::gen::SchemaSettings::draft07(),
                        )
                        .into_root_schema_for::<
                            Vec<
                                nft_marketplace_utils::marketplace_statistics::MarketplaceStatsByDenom,
                            >,
                        >(),
                ),
                (
                    "get_token_id_sale_history".to_string(),
                    ::cosmwasm_schema::schemars::gen::SchemaGenerator::new(
                            ::cosmwasm_schema::schemars::gen::SchemaSettings::draft07(),
                        )
                        .into_root_schema_for::<
                            Vec<nft_marketplace_utils::nft_sale::TokenSaleHistory>,
                        >(),
                ),
                (
                    "get_profile_info".to_string(),
                    ::cosmwasm_schema::schemars::gen::SchemaGenerator::new(
                            ::cosmwasm_schema::schemars::gen::SchemaSettings::draft07(),
                        )
                        .into_root_schema_for::<
                            nft_marketplace_utils::profile::Profile,
                        >(),
                ),
                (
                    "get_all_offers_token_id".to_string(),
                    ::cosmwasm_schema::schemars::gen::SchemaGenerator::new(
                            ::cosmwasm_schema::schemars::gen::SchemaSettings::draft07(),
                        )
                        .into_root_schema_for::<
                            nft_marketplace_utils::nft_offer::NftOffer,
                        >(),
                ),
                (
                    "get_all_offers_address".to_string(),
                    ::cosmwasm_schema::schemars::gen::SchemaGenerator::new(
                            ::cosmwasm_schema::schemars::gen::SchemaSettings::draft07(),
                        )
                        .into_root_schema_for::<
                            Vec<nft_marketplace_utils::nft_offer::NftOffer>,
                        >(),
                ),
                (
                    "get_token_ids_by_collection".to_string(),
                    ::cosmwasm_schema::schemars::gen::SchemaGenerator::new(
                            ::cosmwasm_schema::schemars::gen::SchemaSettings::draft07(),
                        )
                        .into_root_schema_for::<
                            Vec<
                                nft_marketplace_utils::nft_collection::NftCollectionAddress,
                            >,
                        >(),
                ),
            ])
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use ::cosmwasm_schema::serde as _serde;
        #[automatically_derived]
        impl ::cosmwasm_schema::serde::Serialize for QueryMsg {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> ::cosmwasm_schema::serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: ::cosmwasm_schema::serde::Serializer,
            {
                match *self {
                    QueryMsg::GetConfig {} => {
                        let __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "QueryMsg",
                            0u32,
                            "get_config",
                            0,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    QueryMsg::GetMarketplaceVolume {} => {
                        let __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "QueryMsg",
                            1u32,
                            "get_marketplace_volume",
                            0,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    QueryMsg::GetNftCollectionVolume { ref nft_collection_address } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "QueryMsg",
                            2u32,
                            "get_nft_collection_volume",
                            0 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "nft_collection_address",
                            nft_collection_address,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    QueryMsg::GetNftCollectionType { ref nft_collection_address } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "QueryMsg",
                            3u32,
                            "get_nft_collection_type",
                            0 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "nft_collection_address",
                            nft_collection_address,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    QueryMsg::GetNftCollectionInfo { ref nft_collection_address } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "QueryMsg",
                            4u32,
                            "get_nft_collection_info",
                            0 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "nft_collection_address",
                            nft_collection_address,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    QueryMsg::GetNftForSaleInfo {
                        ref nft_collection_address,
                        ref token_id,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "QueryMsg",
                            5u32,
                            "get_nft_for_sale_info",
                            0 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "nft_collection_address",
                            nft_collection_address,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "token_id",
                            token_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    QueryMsg::GetSellerAllNftsForSale {
                        ref seller_address,
                        ref start_after_collection_token_id,
                        ref output_length,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "QueryMsg",
                            6u32,
                            "get_seller_all_nfts_for_sale",
                            0 + 1 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "seller_address",
                            seller_address,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "start_after_collection_token_id",
                            start_after_collection_token_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "output_length",
                            output_length,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    QueryMsg::GetAllTokensByCollAndIfForSale {
                        ref address,
                        ref nft_collection_address,
                        ref output_length,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "QueryMsg",
                            7u32,
                            "get_all_tokens_by_coll_and_if_for_sale",
                            0 + 1 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "address",
                            address,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "nft_collection_address",
                            nft_collection_address,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "output_length",
                            output_length,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    QueryMsg::GetCollectionAllNftsForSale {
                        ref nft_collection_address,
                        ref start_after_token_id,
                        ref output_length,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "QueryMsg",
                            8u32,
                            "get_collection_all_nfts_for_sale",
                            0 + 1 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "nft_collection_address",
                            nft_collection_address,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "start_after_token_id",
                            start_after_token_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "output_length",
                            output_length,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    QueryMsg::GetMarketplaceInfo {} => {
                        let __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "QueryMsg",
                            9u32,
                            "get_marketplace_info",
                            0,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    QueryMsg::GetTokenIdSaleHistory {
                        ref token_id,
                        ref nft_collection_address,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "QueryMsg",
                            10u32,
                            "get_token_id_sale_history",
                            0 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "token_id",
                            token_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "nft_collection_address",
                            nft_collection_address,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    QueryMsg::GetProfileInfo { ref address_or_username } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "QueryMsg",
                            11u32,
                            "get_profile_info",
                            0 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "address_or_username",
                            address_or_username,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    QueryMsg::GetAllOffersTokenId {
                        ref token_id,
                        ref nft_collection_address,
                        ref start_after,
                        ref output_length,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "QueryMsg",
                            12u32,
                            "get_all_offers_token_id",
                            0 + 1 + 1 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "token_id",
                            token_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "nft_collection_address",
                            nft_collection_address,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "start_after",
                            start_after,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "output_length",
                            output_length,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    QueryMsg::GetAllOffersAddress {
                        ref address,
                        ref start_after,
                        ref output_length,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "QueryMsg",
                            13u32,
                            "get_all_offers_address",
                            0 + 1 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "address",
                            address,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "start_after",
                            start_after,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "output_length",
                            output_length,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    QueryMsg::GetTokenIdsByCollection {
                        ref address,
                        ref list_of_collections,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "QueryMsg",
                            14u32,
                            "get_token_ids_by_collection",
                            0 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "address",
                            address,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "list_of_collections",
                            list_of_collections,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        use ::cosmwasm_schema::serde as _serde;
        #[automatically_derived]
        impl<'de> ::cosmwasm_schema::serde::Deserialize<'de> for QueryMsg {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> ::cosmwasm_schema::serde::__private::Result<Self, __D::Error>
            where
                __D: ::cosmwasm_schema::serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __field12,
                    __field13,
                    __field14,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            11u64 => _serde::__private::Ok(__Field::__field11),
                            12u64 => _serde::__private::Ok(__Field::__field12),
                            13u64 => _serde::__private::Ok(__Field::__field13),
                            14u64 => _serde::__private::Ok(__Field::__field14),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 15",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "get_config" => _serde::__private::Ok(__Field::__field0),
                            "get_marketplace_volume" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            "get_nft_collection_volume" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            "get_nft_collection_type" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            "get_nft_collection_info" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            "get_nft_for_sale_info" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            "get_seller_all_nfts_for_sale" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            "get_all_tokens_by_coll_and_if_for_sale" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            "get_collection_all_nfts_for_sale" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            "get_marketplace_info" => {
                                _serde::__private::Ok(__Field::__field9)
                            }
                            "get_token_id_sale_history" => {
                                _serde::__private::Ok(__Field::__field10)
                            }
                            "get_profile_info" => {
                                _serde::__private::Ok(__Field::__field11)
                            }
                            "get_all_offers_token_id" => {
                                _serde::__private::Ok(__Field::__field12)
                            }
                            "get_all_offers_address" => {
                                _serde::__private::Ok(__Field::__field13)
                            }
                            "get_token_ids_by_collection" => {
                                _serde::__private::Ok(__Field::__field14)
                            }
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"get_config" => _serde::__private::Ok(__Field::__field0),
                            b"get_marketplace_volume" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            b"get_nft_collection_volume" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"get_nft_collection_type" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            b"get_nft_collection_info" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            b"get_nft_for_sale_info" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            b"get_seller_all_nfts_for_sale" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            b"get_all_tokens_by_coll_and_if_for_sale" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            b"get_collection_all_nfts_for_sale" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            b"get_marketplace_info" => {
                                _serde::__private::Ok(__Field::__field9)
                            }
                            b"get_token_id_sale_history" => {
                                _serde::__private::Ok(__Field::__field10)
                            }
                            b"get_profile_info" => {
                                _serde::__private::Ok(__Field::__field11)
                            }
                            b"get_all_offers_token_id" => {
                                _serde::__private::Ok(__Field::__field12)
                            }
                            b"get_all_offers_address" => {
                                _serde::__private::Ok(__Field::__field13)
                            }
                            b"get_token_ids_by_collection" => {
                                _serde::__private::Ok(__Field::__field14)
                            }
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<QueryMsg>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = QueryMsg;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum QueryMsg",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {}
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 0",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<QueryMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = QueryMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant QueryMsg::GetConfig",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        _: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        _serde::__private::Ok(QueryMsg::GetConfig {})
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        _serde::__private::Option::map(
                                            match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                            |__impossible| match __impossible {},
                                        );
                                        _serde::__private::Ok(QueryMsg::GetConfig {})
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<QueryMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field1, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {}
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 0",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<QueryMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = QueryMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant QueryMsg::GetMarketplaceVolume",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        _: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        _serde::__private::Ok(QueryMsg::GetMarketplaceVolume {})
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        _serde::__private::Option::map(
                                            match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                            |__impossible| match __impossible {},
                                        );
                                        _serde::__private::Ok(QueryMsg::GetMarketplaceVolume {})
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<QueryMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field2, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 1",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<QueryMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = QueryMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant QueryMsg::GetNftCollectionVolume",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            NftCollectionAddress,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant QueryMsg::GetNftCollectionVolume with 1 element",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(QueryMsg::GetNftCollectionVolume {
                                            nft_collection_address: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            NftCollectionAddress,
                                        > = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "nft_collection_address",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            NftCollectionAddress,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "nft_collection_address",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(QueryMsg::GetNftCollectionVolume {
                                            nft_collection_address: __field0,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[
                                    "nft_collection_address",
                                ];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<QueryMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field3, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 1",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<QueryMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = QueryMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant QueryMsg::GetNftCollectionType",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            NftCollectionAddress,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant QueryMsg::GetNftCollectionType with 1 element",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(QueryMsg::GetNftCollectionType {
                                            nft_collection_address: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            NftCollectionAddress,
                                        > = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "nft_collection_address",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            NftCollectionAddress,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "nft_collection_address",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(QueryMsg::GetNftCollectionType {
                                            nft_collection_address: __field0,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[
                                    "nft_collection_address",
                                ];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<QueryMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field4, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 1",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<QueryMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = QueryMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant QueryMsg::GetNftCollectionInfo",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            NftCollectionAddress,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant QueryMsg::GetNftCollectionInfo with 1 element",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(QueryMsg::GetNftCollectionInfo {
                                            nft_collection_address: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            NftCollectionAddress,
                                        > = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "nft_collection_address",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            NftCollectionAddress,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "nft_collection_address",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(QueryMsg::GetNftCollectionInfo {
                                            nft_collection_address: __field0,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[
                                    "nft_collection_address",
                                ];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<QueryMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field5, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 2",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            "token_id" => _serde::__private::Ok(__Field::__field1),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            b"token_id" => _serde::__private::Ok(__Field::__field1),
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<QueryMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = QueryMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant QueryMsg::GetNftForSaleInfo",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            NftCollectionAddress,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant QueryMsg::GetNftForSaleInfo with 2 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                                            TokenId,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        1usize,
                                                        &"struct variant QueryMsg::GetNftForSaleInfo with 2 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(QueryMsg::GetNftForSaleInfo {
                                            nft_collection_address: __field0,
                                            token_id: __field1,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            NftCollectionAddress,
                                        > = _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<TokenId> = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "nft_collection_address",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            NftCollectionAddress,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "token_id",
                                                            ),
                                                        );
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            TokenId,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "nft_collection_address",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("token_id") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(QueryMsg::GetNftForSaleInfo {
                                            nft_collection_address: __field0,
                                            token_id: __field1,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[
                                    "nft_collection_address",
                                    "token_id",
                                ];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<QueryMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field6, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __field2,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            2u64 => _serde::__private::Ok(__Field::__field2),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 3",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "seller_address" => _serde::__private::Ok(__Field::__field0),
                                            "start_after_collection_token_id" => {
                                                _serde::__private::Ok(__Field::__field1)
                                            }
                                            "output_length" => _serde::__private::Ok(__Field::__field2),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"seller_address" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            b"start_after_collection_token_id" => {
                                                _serde::__private::Ok(__Field::__field1)
                                            }
                                            b"output_length" => _serde::__private::Ok(__Field::__field2),
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<QueryMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = QueryMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant QueryMsg::GetSellerAllNftsForSale",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            String,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant QueryMsg::GetSellerAllNftsForSale with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                                            Option<NftCollectionAddressTokenId>,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        1usize,
                                                        &"struct variant QueryMsg::GetSellerAllNftsForSale with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                                            Option<u32>,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        2usize,
                                                        &"struct variant QueryMsg::GetSellerAllNftsForSale with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(QueryMsg::GetSellerAllNftsForSale {
                                            seller_address: __field0,
                                            start_after_collection_token_id: __field1,
                                            output_length: __field2,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<
                                            Option<NftCollectionAddressTokenId>,
                                        > = _serde::__private::None;
                                        let mut __field2: _serde::__private::Option<Option<u32>> = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "seller_address",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            String,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "start_after_collection_token_id",
                                                            ),
                                                        );
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Option<NftCollectionAddressTokenId>,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field2 => {
                                                    if _serde::__private::Option::is_some(&__field2) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "output_length",
                                                            ),
                                                        );
                                                    }
                                                    __field2 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Option<u32>,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "seller_address",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "start_after_collection_token_id",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field2 = match __field2 {
                                            _serde::__private::Some(__field2) => __field2,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "output_length",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(QueryMsg::GetSellerAllNftsForSale {
                                            seller_address: __field0,
                                            start_after_collection_token_id: __field1,
                                            output_length: __field2,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[
                                    "seller_address",
                                    "start_after_collection_token_id",
                                    "output_length",
                                ];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<QueryMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field7, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __field2,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            2u64 => _serde::__private::Ok(__Field::__field2),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 3",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "address" => _serde::__private::Ok(__Field::__field0),
                                            "nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field1)
                                            }
                                            "output_length" => _serde::__private::Ok(__Field::__field2),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"address" => _serde::__private::Ok(__Field::__field0),
                                            b"nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field1)
                                            }
                                            b"output_length" => _serde::__private::Ok(__Field::__field2),
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<QueryMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = QueryMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant QueryMsg::GetAllTokensByCollAndIfForSale",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            String,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant QueryMsg::GetAllTokensByCollAndIfForSale with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                                            NftCollectionAddress,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        1usize,
                                                        &"struct variant QueryMsg::GetAllTokensByCollAndIfForSale with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                                            Option<u32>,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        2usize,
                                                        &"struct variant QueryMsg::GetAllTokensByCollAndIfForSale with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(QueryMsg::GetAllTokensByCollAndIfForSale {
                                            address: __field0,
                                            nft_collection_address: __field1,
                                            output_length: __field2,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<
                                            NftCollectionAddress,
                                        > = _serde::__private::None;
                                        let mut __field2: _serde::__private::Option<Option<u32>> = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "address",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            String,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "nft_collection_address",
                                                            ),
                                                        );
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            NftCollectionAddress,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field2 => {
                                                    if _serde::__private::Option::is_some(&__field2) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "output_length",
                                                            ),
                                                        );
                                                    }
                                                    __field2 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Option<u32>,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("address") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "nft_collection_address",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field2 = match __field2 {
                                            _serde::__private::Some(__field2) => __field2,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "output_length",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(QueryMsg::GetAllTokensByCollAndIfForSale {
                                            address: __field0,
                                            nft_collection_address: __field1,
                                            output_length: __field2,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[
                                    "address",
                                    "nft_collection_address",
                                    "output_length",
                                ];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<QueryMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field8, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __field2,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            2u64 => _serde::__private::Ok(__Field::__field2),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 3",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            "start_after_token_id" => {
                                                _serde::__private::Ok(__Field::__field1)
                                            }
                                            "output_length" => _serde::__private::Ok(__Field::__field2),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            b"start_after_token_id" => {
                                                _serde::__private::Ok(__Field::__field1)
                                            }
                                            b"output_length" => _serde::__private::Ok(__Field::__field2),
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<QueryMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = QueryMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant QueryMsg::GetCollectionAllNftsForSale",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            NftCollectionAddress,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant QueryMsg::GetCollectionAllNftsForSale with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                                            Option<TokenId>,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        1usize,
                                                        &"struct variant QueryMsg::GetCollectionAllNftsForSale with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                                            Option<u32>,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        2usize,
                                                        &"struct variant QueryMsg::GetCollectionAllNftsForSale with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(QueryMsg::GetCollectionAllNftsForSale {
                                            nft_collection_address: __field0,
                                            start_after_token_id: __field1,
                                            output_length: __field2,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            NftCollectionAddress,
                                        > = _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<
                                            Option<TokenId>,
                                        > = _serde::__private::None;
                                        let mut __field2: _serde::__private::Option<Option<u32>> = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "nft_collection_address",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            NftCollectionAddress,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "start_after_token_id",
                                                            ),
                                                        );
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Option<TokenId>,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field2 => {
                                                    if _serde::__private::Option::is_some(&__field2) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "output_length",
                                                            ),
                                                        );
                                                    }
                                                    __field2 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Option<u32>,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "nft_collection_address",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "start_after_token_id",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field2 = match __field2 {
                                            _serde::__private::Some(__field2) => __field2,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "output_length",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(QueryMsg::GetCollectionAllNftsForSale {
                                            nft_collection_address: __field0,
                                            start_after_token_id: __field1,
                                            output_length: __field2,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[
                                    "nft_collection_address",
                                    "start_after_token_id",
                                    "output_length",
                                ];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<QueryMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field9, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {}
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 0",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<QueryMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = QueryMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant QueryMsg::GetMarketplaceInfo",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        _: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        _serde::__private::Ok(QueryMsg::GetMarketplaceInfo {})
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        _serde::__private::Option::map(
                                            match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                            |__impossible| match __impossible {},
                                        );
                                        _serde::__private::Ok(QueryMsg::GetMarketplaceInfo {})
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<QueryMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field10, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 2",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "token_id" => _serde::__private::Ok(__Field::__field0),
                                            "nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field1)
                                            }
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"token_id" => _serde::__private::Ok(__Field::__field0),
                                            b"nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field1)
                                            }
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<QueryMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = QueryMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant QueryMsg::GetTokenIdSaleHistory",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            TokenId,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant QueryMsg::GetTokenIdSaleHistory with 2 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                                            NftCollectionAddress,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        1usize,
                                                        &"struct variant QueryMsg::GetTokenIdSaleHistory with 2 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(QueryMsg::GetTokenIdSaleHistory {
                                            token_id: __field0,
                                            nft_collection_address: __field1,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<TokenId> = _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<
                                            NftCollectionAddress,
                                        > = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "token_id",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            TokenId,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "nft_collection_address",
                                                            ),
                                                        );
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            NftCollectionAddress,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("token_id") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "nft_collection_address",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(QueryMsg::GetTokenIdSaleHistory {
                                            token_id: __field0,
                                            nft_collection_address: __field1,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[
                                    "token_id",
                                    "nft_collection_address",
                                ];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<QueryMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field11, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 1",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "address_or_username" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"address_or_username" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<QueryMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = QueryMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant QueryMsg::GetProfileInfo",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            String,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant QueryMsg::GetProfileInfo with 1 element",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(QueryMsg::GetProfileInfo {
                                            address_or_username: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "address_or_username",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            String,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "address_or_username",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(QueryMsg::GetProfileInfo {
                                            address_or_username: __field0,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[
                                    "address_or_username",
                                ];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<QueryMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field12, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __field2,
                                    __field3,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            2u64 => _serde::__private::Ok(__Field::__field2),
                                            3u64 => _serde::__private::Ok(__Field::__field3),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 4",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "token_id" => _serde::__private::Ok(__Field::__field0),
                                            "nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field1)
                                            }
                                            "start_after" => _serde::__private::Ok(__Field::__field2),
                                            "output_length" => _serde::__private::Ok(__Field::__field3),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"token_id" => _serde::__private::Ok(__Field::__field0),
                                            b"nft_collection_address" => {
                                                _serde::__private::Ok(__Field::__field1)
                                            }
                                            b"start_after" => _serde::__private::Ok(__Field::__field2),
                                            b"output_length" => _serde::__private::Ok(__Field::__field3),
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<QueryMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = QueryMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant QueryMsg::GetAllOffersTokenId",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            TokenId,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant QueryMsg::GetAllOffersTokenId with 4 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                                            NftCollectionAddress,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        1usize,
                                                        &"struct variant QueryMsg::GetAllOffersTokenId with 4 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                                            Option<(NftCollectionAddress, TokenId)>,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        2usize,
                                                        &"struct variant QueryMsg::GetAllOffersTokenId with 4 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field3 = match match _serde::de::SeqAccess::next_element::<
                                            Option<u32>,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        3usize,
                                                        &"struct variant QueryMsg::GetAllOffersTokenId with 4 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(QueryMsg::GetAllOffersTokenId {
                                            token_id: __field0,
                                            nft_collection_address: __field1,
                                            start_after: __field2,
                                            output_length: __field3,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<TokenId> = _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<
                                            NftCollectionAddress,
                                        > = _serde::__private::None;
                                        let mut __field2: _serde::__private::Option<
                                            Option<(NftCollectionAddress, TokenId)>,
                                        > = _serde::__private::None;
                                        let mut __field3: _serde::__private::Option<Option<u32>> = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "token_id",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            TokenId,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "nft_collection_address",
                                                            ),
                                                        );
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            NftCollectionAddress,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field2 => {
                                                    if _serde::__private::Option::is_some(&__field2) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "start_after",
                                                            ),
                                                        );
                                                    }
                                                    __field2 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Option<(NftCollectionAddress, TokenId)>,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field3 => {
                                                    if _serde::__private::Option::is_some(&__field3) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "output_length",
                                                            ),
                                                        );
                                                    }
                                                    __field3 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Option<u32>,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("token_id") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "nft_collection_address",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field2 = match __field2 {
                                            _serde::__private::Some(__field2) => __field2,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("start_after") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field3 = match __field3 {
                                            _serde::__private::Some(__field3) => __field3,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "output_length",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(QueryMsg::GetAllOffersTokenId {
                                            token_id: __field0,
                                            nft_collection_address: __field1,
                                            start_after: __field2,
                                            output_length: __field3,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[
                                    "token_id",
                                    "nft_collection_address",
                                    "start_after",
                                    "output_length",
                                ];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<QueryMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field13, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __field2,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            2u64 => _serde::__private::Ok(__Field::__field2),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 3",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "address" => _serde::__private::Ok(__Field::__field0),
                                            "start_after" => _serde::__private::Ok(__Field::__field1),
                                            "output_length" => _serde::__private::Ok(__Field::__field2),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"address" => _serde::__private::Ok(__Field::__field0),
                                            b"start_after" => _serde::__private::Ok(__Field::__field1),
                                            b"output_length" => _serde::__private::Ok(__Field::__field2),
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<QueryMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = QueryMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant QueryMsg::GetAllOffersAddress",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            String,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant QueryMsg::GetAllOffersAddress with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                                            Option<(NftCollectionAddress, TokenId)>,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        1usize,
                                                        &"struct variant QueryMsg::GetAllOffersAddress with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                                            Option<u32>,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        2usize,
                                                        &"struct variant QueryMsg::GetAllOffersAddress with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(QueryMsg::GetAllOffersAddress {
                                            address: __field0,
                                            start_after: __field1,
                                            output_length: __field2,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<
                                            Option<(NftCollectionAddress, TokenId)>,
                                        > = _serde::__private::None;
                                        let mut __field2: _serde::__private::Option<Option<u32>> = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "address",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            String,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "start_after",
                                                            ),
                                                        );
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Option<(NftCollectionAddress, TokenId)>,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field2 => {
                                                    if _serde::__private::Option::is_some(&__field2) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "output_length",
                                                            ),
                                                        );
                                                    }
                                                    __field2 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Option<u32>,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("address") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("start_after") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field2 = match __field2 {
                                            _serde::__private::Some(__field2) => __field2,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "output_length",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(QueryMsg::GetAllOffersAddress {
                                            address: __field0,
                                            start_after: __field1,
                                            output_length: __field2,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[
                                    "address",
                                    "start_after",
                                    "output_length",
                                ];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<QueryMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field14, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 2",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "address" => _serde::__private::Ok(__Field::__field0),
                                            "list_of_collections" => {
                                                _serde::__private::Ok(__Field::__field1)
                                            }
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"address" => _serde::__private::Ok(__Field::__field0),
                                            b"list_of_collections" => {
                                                _serde::__private::Ok(__Field::__field1)
                                            }
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_field(__value, FIELDS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<QueryMsg>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = QueryMsg;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant QueryMsg::GetTokenIdsByCollection",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                                            String,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant QueryMsg::GetTokenIdsByCollection with 2 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                                            Vec<NftCollectionAddress>,
                                        >(&mut __seq) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        } {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        1usize,
                                                        &"struct variant QueryMsg::GetTokenIdsByCollection with 2 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(QueryMsg::GetTokenIdsByCollection {
                                            address: __field0,
                                            list_of_collections: __field1,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<
                                            Vec<NftCollectionAddress>,
                                        > = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = match _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "address",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            String,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "list_of_collections",
                                                            ),
                                                        );
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Vec<NftCollectionAddress>,
                                                        >(&mut __map) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("address") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "list_of_collections",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(QueryMsg::GetTokenIdsByCollection {
                                            address: __field0,
                                            list_of_collections: __field1,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[
                                    "address",
                                    "list_of_collections",
                                ];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<QueryMsg>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &[
                    "get_config",
                    "get_marketplace_volume",
                    "get_nft_collection_volume",
                    "get_nft_collection_type",
                    "get_nft_collection_info",
                    "get_nft_for_sale_info",
                    "get_seller_all_nfts_for_sale",
                    "get_all_tokens_by_coll_and_if_for_sale",
                    "get_collection_all_nfts_for_sale",
                    "get_marketplace_info",
                    "get_token_id_sale_history",
                    "get_profile_info",
                    "get_all_offers_token_id",
                    "get_all_offers_address",
                    "get_token_ids_by_collection",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "QueryMsg",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<QueryMsg>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for QueryMsg {
        #[inline]
        fn clone(&self) -> QueryMsg {
            match self {
                QueryMsg::GetConfig {} => QueryMsg::GetConfig {},
                QueryMsg::GetMarketplaceVolume {} => QueryMsg::GetMarketplaceVolume {},
                QueryMsg::GetNftCollectionVolume { nft_collection_address: __self_0 } => {
                    QueryMsg::GetNftCollectionVolume {
                        nft_collection_address: ::core::clone::Clone::clone(__self_0),
                    }
                }
                QueryMsg::GetNftCollectionType { nft_collection_address: __self_0 } => {
                    QueryMsg::GetNftCollectionType {
                        nft_collection_address: ::core::clone::Clone::clone(__self_0),
                    }
                }
                QueryMsg::GetNftCollectionInfo { nft_collection_address: __self_0 } => {
                    QueryMsg::GetNftCollectionInfo {
                        nft_collection_address: ::core::clone::Clone::clone(__self_0),
                    }
                }
                QueryMsg::GetNftForSaleInfo {
                    nft_collection_address: __self_0,
                    token_id: __self_1,
                } => {
                    QueryMsg::GetNftForSaleInfo {
                        nft_collection_address: ::core::clone::Clone::clone(__self_0),
                        token_id: ::core::clone::Clone::clone(__self_1),
                    }
                }
                QueryMsg::GetSellerAllNftsForSale {
                    seller_address: __self_0,
                    start_after_collection_token_id: __self_1,
                    output_length: __self_2,
                } => {
                    QueryMsg::GetSellerAllNftsForSale {
                        seller_address: ::core::clone::Clone::clone(__self_0),
                        start_after_collection_token_id: ::core::clone::Clone::clone(
                            __self_1,
                        ),
                        output_length: ::core::clone::Clone::clone(__self_2),
                    }
                }
                QueryMsg::GetAllTokensByCollAndIfForSale {
                    address: __self_0,
                    nft_collection_address: __self_1,
                    output_length: __self_2,
                } => {
                    QueryMsg::GetAllTokensByCollAndIfForSale {
                        address: ::core::clone::Clone::clone(__self_0),
                        nft_collection_address: ::core::clone::Clone::clone(__self_1),
                        output_length: ::core::clone::Clone::clone(__self_2),
                    }
                }
                QueryMsg::GetCollectionAllNftsForSale {
                    nft_collection_address: __self_0,
                    start_after_token_id: __self_1,
                    output_length: __self_2,
                } => {
                    QueryMsg::GetCollectionAllNftsForSale {
                        nft_collection_address: ::core::clone::Clone::clone(__self_0),
                        start_after_token_id: ::core::clone::Clone::clone(__self_1),
                        output_length: ::core::clone::Clone::clone(__self_2),
                    }
                }
                QueryMsg::GetMarketplaceInfo {} => QueryMsg::GetMarketplaceInfo {},
                QueryMsg::GetTokenIdSaleHistory {
                    token_id: __self_0,
                    nft_collection_address: __self_1,
                } => {
                    QueryMsg::GetTokenIdSaleHistory {
                        token_id: ::core::clone::Clone::clone(__self_0),
                        nft_collection_address: ::core::clone::Clone::clone(__self_1),
                    }
                }
                QueryMsg::GetProfileInfo { address_or_username: __self_0 } => {
                    QueryMsg::GetProfileInfo {
                        address_or_username: ::core::clone::Clone::clone(__self_0),
                    }
                }
                QueryMsg::GetAllOffersTokenId {
                    token_id: __self_0,
                    nft_collection_address: __self_1,
                    start_after: __self_2,
                    output_length: __self_3,
                } => {
                    QueryMsg::GetAllOffersTokenId {
                        token_id: ::core::clone::Clone::clone(__self_0),
                        nft_collection_address: ::core::clone::Clone::clone(__self_1),
                        start_after: ::core::clone::Clone::clone(__self_2),
                        output_length: ::core::clone::Clone::clone(__self_3),
                    }
                }
                QueryMsg::GetAllOffersAddress {
                    address: __self_0,
                    start_after: __self_1,
                    output_length: __self_2,
                } => {
                    QueryMsg::GetAllOffersAddress {
                        address: ::core::clone::Clone::clone(__self_0),
                        start_after: ::core::clone::Clone::clone(__self_1),
                        output_length: ::core::clone::Clone::clone(__self_2),
                    }
                }
                QueryMsg::GetTokenIdsByCollection {
                    address: __self_0,
                    list_of_collections: __self_1,
                } => {
                    QueryMsg::GetTokenIdsByCollection {
                        address: ::core::clone::Clone::clone(__self_0),
                        list_of_collections: ::core::clone::Clone::clone(__self_1),
                    }
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::fmt::Debug for QueryMsg {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                QueryMsg::GetConfig {} => {
                    ::core::fmt::Formatter::write_str(f, "GetConfig")
                }
                QueryMsg::GetMarketplaceVolume {} => {
                    ::core::fmt::Formatter::write_str(f, "GetMarketplaceVolume")
                }
                QueryMsg::GetNftCollectionVolume { nft_collection_address: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "GetNftCollectionVolume",
                        "nft_collection_address",
                        &__self_0,
                    )
                }
                QueryMsg::GetNftCollectionType { nft_collection_address: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "GetNftCollectionType",
                        "nft_collection_address",
                        &__self_0,
                    )
                }
                QueryMsg::GetNftCollectionInfo { nft_collection_address: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "GetNftCollectionInfo",
                        "nft_collection_address",
                        &__self_0,
                    )
                }
                QueryMsg::GetNftForSaleInfo {
                    nft_collection_address: __self_0,
                    token_id: __self_1,
                } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "GetNftForSaleInfo",
                        "nft_collection_address",
                        __self_0,
                        "token_id",
                        &__self_1,
                    )
                }
                QueryMsg::GetSellerAllNftsForSale {
                    seller_address: __self_0,
                    start_after_collection_token_id: __self_1,
                    output_length: __self_2,
                } => {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "GetSellerAllNftsForSale",
                        "seller_address",
                        __self_0,
                        "start_after_collection_token_id",
                        __self_1,
                        "output_length",
                        &__self_2,
                    )
                }
                QueryMsg::GetAllTokensByCollAndIfForSale {
                    address: __self_0,
                    nft_collection_address: __self_1,
                    output_length: __self_2,
                } => {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "GetAllTokensByCollAndIfForSale",
                        "address",
                        __self_0,
                        "nft_collection_address",
                        __self_1,
                        "output_length",
                        &__self_2,
                    )
                }
                QueryMsg::GetCollectionAllNftsForSale {
                    nft_collection_address: __self_0,
                    start_after_token_id: __self_1,
                    output_length: __self_2,
                } => {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "GetCollectionAllNftsForSale",
                        "nft_collection_address",
                        __self_0,
                        "start_after_token_id",
                        __self_1,
                        "output_length",
                        &__self_2,
                    )
                }
                QueryMsg::GetMarketplaceInfo {} => {
                    ::core::fmt::Formatter::write_str(f, "GetMarketplaceInfo")
                }
                QueryMsg::GetTokenIdSaleHistory {
                    token_id: __self_0,
                    nft_collection_address: __self_1,
                } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "GetTokenIdSaleHistory",
                        "token_id",
                        __self_0,
                        "nft_collection_address",
                        &__self_1,
                    )
                }
                QueryMsg::GetProfileInfo { address_or_username: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "GetProfileInfo",
                        "address_or_username",
                        &__self_0,
                    )
                }
                QueryMsg::GetAllOffersTokenId {
                    token_id: __self_0,
                    nft_collection_address: __self_1,
                    start_after: __self_2,
                    output_length: __self_3,
                } => {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "GetAllOffersTokenId",
                        "token_id",
                        __self_0,
                        "nft_collection_address",
                        __self_1,
                        "start_after",
                        __self_2,
                        "output_length",
                        &__self_3,
                    )
                }
                QueryMsg::GetAllOffersAddress {
                    address: __self_0,
                    start_after: __self_1,
                    output_length: __self_2,
                } => {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "GetAllOffersAddress",
                        "address",
                        __self_0,
                        "start_after",
                        __self_1,
                        "output_length",
                        &__self_2,
                    )
                }
                QueryMsg::GetTokenIdsByCollection {
                    address: __self_0,
                    list_of_collections: __self_1,
                } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "GetTokenIdsByCollection",
                        "address",
                        __self_0,
                        "list_of_collections",
                        &__self_1,
                    )
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for QueryMsg {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for QueryMsg {
        #[inline]
        fn eq(&self, other: &QueryMsg) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        QueryMsg::GetNftCollectionVolume {
                            nft_collection_address: __self_0,
                        },
                        QueryMsg::GetNftCollectionVolume {
                            nft_collection_address: __arg1_0,
                        },
                    ) => *__self_0 == *__arg1_0,
                    (
                        QueryMsg::GetNftCollectionType {
                            nft_collection_address: __self_0,
                        },
                        QueryMsg::GetNftCollectionType {
                            nft_collection_address: __arg1_0,
                        },
                    ) => *__self_0 == *__arg1_0,
                    (
                        QueryMsg::GetNftCollectionInfo {
                            nft_collection_address: __self_0,
                        },
                        QueryMsg::GetNftCollectionInfo {
                            nft_collection_address: __arg1_0,
                        },
                    ) => *__self_0 == *__arg1_0,
                    (
                        QueryMsg::GetNftForSaleInfo {
                            nft_collection_address: __self_0,
                            token_id: __self_1,
                        },
                        QueryMsg::GetNftForSaleInfo {
                            nft_collection_address: __arg1_0,
                            token_id: __arg1_1,
                        },
                    ) => *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,
                    (
                        QueryMsg::GetSellerAllNftsForSale {
                            seller_address: __self_0,
                            start_after_collection_token_id: __self_1,
                            output_length: __self_2,
                        },
                        QueryMsg::GetSellerAllNftsForSale {
                            seller_address: __arg1_0,
                            start_after_collection_token_id: __arg1_1,
                            output_length: __arg1_2,
                        },
                    ) => {
                        *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1
                            && *__self_2 == *__arg1_2
                    }
                    (
                        QueryMsg::GetAllTokensByCollAndIfForSale {
                            address: __self_0,
                            nft_collection_address: __self_1,
                            output_length: __self_2,
                        },
                        QueryMsg::GetAllTokensByCollAndIfForSale {
                            address: __arg1_0,
                            nft_collection_address: __arg1_1,
                            output_length: __arg1_2,
                        },
                    ) => {
                        *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1
                            && *__self_2 == *__arg1_2
                    }
                    (
                        QueryMsg::GetCollectionAllNftsForSale {
                            nft_collection_address: __self_0,
                            start_after_token_id: __self_1,
                            output_length: __self_2,
                        },
                        QueryMsg::GetCollectionAllNftsForSale {
                            nft_collection_address: __arg1_0,
                            start_after_token_id: __arg1_1,
                            output_length: __arg1_2,
                        },
                    ) => {
                        *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1
                            && *__self_2 == *__arg1_2
                    }
                    (
                        QueryMsg::GetTokenIdSaleHistory {
                            token_id: __self_0,
                            nft_collection_address: __self_1,
                        },
                        QueryMsg::GetTokenIdSaleHistory {
                            token_id: __arg1_0,
                            nft_collection_address: __arg1_1,
                        },
                    ) => *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,
                    (
                        QueryMsg::GetProfileInfo { address_or_username: __self_0 },
                        QueryMsg::GetProfileInfo { address_or_username: __arg1_0 },
                    ) => *__self_0 == *__arg1_0,
                    (
                        QueryMsg::GetAllOffersTokenId {
                            token_id: __self_0,
                            nft_collection_address: __self_1,
                            start_after: __self_2,
                            output_length: __self_3,
                        },
                        QueryMsg::GetAllOffersTokenId {
                            token_id: __arg1_0,
                            nft_collection_address: __arg1_1,
                            start_after: __arg1_2,
                            output_length: __arg1_3,
                        },
                    ) => {
                        *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1
                            && *__self_2 == *__arg1_2 && *__self_3 == *__arg1_3
                    }
                    (
                        QueryMsg::GetAllOffersAddress {
                            address: __self_0,
                            start_after: __self_1,
                            output_length: __self_2,
                        },
                        QueryMsg::GetAllOffersAddress {
                            address: __arg1_0,
                            start_after: __arg1_1,
                            output_length: __arg1_2,
                        },
                    ) => {
                        *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1
                            && *__self_2 == *__arg1_2
                    }
                    (
                        QueryMsg::GetTokenIdsByCollection {
                            address: __self_0,
                            list_of_collections: __self_1,
                        },
                        QueryMsg::GetTokenIdsByCollection {
                            address: __arg1_0,
                            list_of_collections: __arg1_1,
                        },
                    ) => *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,
                    _ => true,
                }
        }
    }
    const _: () = {
        use ::cosmwasm_schema::schemars as schemars;
        #[automatically_derived]
        #[allow(unused_braces)]
        impl schemars::JsonSchema for QueryMsg {
            fn schema_name() -> std::string::String {
                "QueryMsg".to_owned()
            }
            fn json_schema(
                gen: &mut schemars::gen::SchemaGenerator,
            ) -> schemars::schema::Schema {
                schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                    subschemas: Some(
                        Box::new(schemars::schema::SubschemaValidation {
                            one_of: Some(
                                <[_]>::into_vec(
                                    #[rustc_box]
                                    ::alloc::boxed::Box::new([
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "get_config".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("get_config".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "get_marketplace_volume".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("get_marketplace_volume".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "get_nft_collection_volume".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "nft_collection_address".to_owned(),
                                                                                gen.subschema_for::<NftCollectionAddress>(),
                                                                            );
                                                                        if !<NftCollectionAddress as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("nft_collection_address".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("get_nft_collection_volume".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "get_nft_collection_type".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "nft_collection_address".to_owned(),
                                                                                gen.subschema_for::<NftCollectionAddress>(),
                                                                            );
                                                                        if !<NftCollectionAddress as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("nft_collection_address".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("get_nft_collection_type".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "get_nft_collection_info".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "nft_collection_address".to_owned(),
                                                                                gen.subschema_for::<NftCollectionAddress>(),
                                                                            );
                                                                        if !<NftCollectionAddress as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("nft_collection_address".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("get_nft_collection_info".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "get_nft_for_sale_info".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "nft_collection_address".to_owned(),
                                                                                gen.subschema_for::<NftCollectionAddress>(),
                                                                            );
                                                                        if !<NftCollectionAddress as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("nft_collection_address".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "token_id".to_owned(),
                                                                                gen.subschema_for::<TokenId>(),
                                                                            );
                                                                        if !<TokenId as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation.required.insert("token_id".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("get_nft_for_sale_info".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "get_seller_all_nfts_for_sale".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "seller_address".to_owned(),
                                                                                gen.subschema_for::<String>(),
                                                                            );
                                                                        if !<String as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("seller_address".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "start_after_collection_token_id".to_owned(),
                                                                                gen.subschema_for::<Option<NftCollectionAddressTokenId>>(),
                                                                            );
                                                                        if !<Option<
                                                                            NftCollectionAddressTokenId,
                                                                        > as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("start_after_collection_token_id".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "output_length".to_owned(),
                                                                                gen.subschema_for::<Option<u32>>(),
                                                                            );
                                                                        if !<Option<
                                                                            u32,
                                                                        > as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("output_length".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("get_seller_all_nfts_for_sale".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "get_all_tokens_by_coll_and_if_for_sale".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "address".to_owned(),
                                                                                gen.subschema_for::<String>(),
                                                                            );
                                                                        if !<String as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation.required.insert("address".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "nft_collection_address".to_owned(),
                                                                                gen.subschema_for::<NftCollectionAddress>(),
                                                                            );
                                                                        if !<NftCollectionAddress as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("nft_collection_address".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "output_length".to_owned(),
                                                                                gen.subschema_for::<Option<u32>>(),
                                                                            );
                                                                        if !<Option<
                                                                            u32,
                                                                        > as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("output_length".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required
                                                            .insert(
                                                                "get_all_tokens_by_coll_and_if_for_sale".to_owned(),
                                                            );
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "get_collection_all_nfts_for_sale".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "nft_collection_address".to_owned(),
                                                                                gen.subschema_for::<NftCollectionAddress>(),
                                                                            );
                                                                        if !<NftCollectionAddress as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("nft_collection_address".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "start_after_token_id".to_owned(),
                                                                                gen.subschema_for::<Option<TokenId>>(),
                                                                            );
                                                                        if !<Option<
                                                                            TokenId,
                                                                        > as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("start_after_token_id".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "output_length".to_owned(),
                                                                                gen.subschema_for::<Option<u32>>(),
                                                                            );
                                                                        if !<Option<
                                                                            u32,
                                                                        > as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("output_length".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required
                                                            .insert("get_collection_all_nfts_for_sale".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "get_marketplace_info".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("get_marketplace_info".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "get_token_id_sale_history".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "token_id".to_owned(),
                                                                                gen.subschema_for::<TokenId>(),
                                                                            );
                                                                        if !<TokenId as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation.required.insert("token_id".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "nft_collection_address".to_owned(),
                                                                                gen.subschema_for::<NftCollectionAddress>(),
                                                                            );
                                                                        if !<NftCollectionAddress as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("nft_collection_address".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("get_token_id_sale_history".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "get_profile_info".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "address_or_username".to_owned(),
                                                                                gen.subschema_for::<String>(),
                                                                            );
                                                                        if !<String as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("address_or_username".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("get_profile_info".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "get_all_offers_token_id".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "token_id".to_owned(),
                                                                                gen.subschema_for::<TokenId>(),
                                                                            );
                                                                        if !<TokenId as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation.required.insert("token_id".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "nft_collection_address".to_owned(),
                                                                                gen.subschema_for::<NftCollectionAddress>(),
                                                                            );
                                                                        if !<NftCollectionAddress as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("nft_collection_address".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "start_after".to_owned(),
                                                                                gen
                                                                                    .subschema_for::<Option<(NftCollectionAddress, TokenId)>>(),
                                                                            );
                                                                        if !<Option<
                                                                            (NftCollectionAddress, TokenId),
                                                                        > as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation.required.insert("start_after".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "output_length".to_owned(),
                                                                                gen.subschema_for::<Option<u32>>(),
                                                                            );
                                                                        if !<Option<
                                                                            u32,
                                                                        > as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("output_length".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("get_all_offers_token_id".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "get_all_offers_address".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "address".to_owned(),
                                                                                gen.subschema_for::<String>(),
                                                                            );
                                                                        if !<String as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation.required.insert("address".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "start_after".to_owned(),
                                                                                gen
                                                                                    .subschema_for::<Option<(NftCollectionAddress, TokenId)>>(),
                                                                            );
                                                                        if !<Option<
                                                                            (NftCollectionAddress, TokenId),
                                                                        > as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation.required.insert("start_after".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "output_length".to_owned(),
                                                                                gen.subschema_for::<Option<u32>>(),
                                                                            );
                                                                        if !<Option<
                                                                            u32,
                                                                        > as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("output_length".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("get_all_offers_address".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                        schemars::schema::Schema::Object(schemars::schema::SchemaObject {
                                            instance_type: Some(
                                                schemars::schema::InstanceType::Object.into(),
                                            ),
                                            object: Some(
                                                Box::new(schemars::schema::ObjectValidation {
                                                    properties: {
                                                        let mut props = schemars::Map::new();
                                                        props
                                                            .insert(
                                                                "get_token_ids_by_collection".to_owned(),
                                                                {
                                                                    let mut schema_object = schemars::schema::SchemaObject {
                                                                        instance_type: Some(
                                                                            schemars::schema::InstanceType::Object.into(),
                                                                        ),
                                                                        ..Default::default()
                                                                    };
                                                                    let object_validation = schema_object.object();
                                                                    object_validation
                                                                        .additional_properties = Some(Box::new(false.into()));
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "address".to_owned(),
                                                                                gen.subschema_for::<String>(),
                                                                            );
                                                                        if !<String as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation.required.insert("address".to_owned());
                                                                        }
                                                                    }
                                                                    {
                                                                        object_validation
                                                                            .properties
                                                                            .insert(
                                                                                "list_of_collections".to_owned(),
                                                                                gen.subschema_for::<Vec<NftCollectionAddress>>(),
                                                                            );
                                                                        if !<Vec<
                                                                            NftCollectionAddress,
                                                                        > as schemars::JsonSchema>::_schemars_private_is_option() {
                                                                            object_validation
                                                                                .required
                                                                                .insert("list_of_collections".to_owned());
                                                                        }
                                                                    }
                                                                    schemars::schema::Schema::Object(schema_object)
                                                                },
                                                            );
                                                        props
                                                    },
                                                    required: {
                                                        let mut required = schemars::Set::new();
                                                        required.insert("get_token_ids_by_collection".to_owned());
                                                        required
                                                    },
                                                    additional_properties: Some(Box::new(false.into())),
                                                    ..Default::default()
                                                }),
                                            ),
                                            ..Default::default()
                                        }),
                                    ]),
                                ),
                            ),
                            ..Default::default()
                        }),
                    ),
                    ..Default::default()
                })
            }
        }
    };
}
pub mod query {
    use std::marker::PhantomData;
    use cosmwasm_std::{
        Addr, Deps, Empty, Order, QueryRequest, StdError, StdResult, to_binary, Uint128,
        WasmQuery,
    };
    use cw721::{Cw721QueryMsg, TokensResponse};
    use cw721_base::helpers::Cw721Contract;
    use cw_storage_plus::Bound;
    use nft_marketplace_utils::config::{Config, ConfigRewardGenStatsMsg};
    use nft_marketplace_utils::marketplace_statistics::MarketplaceStatsByDenom;
    use nft_marketplace_utils::nft_collection::{
        nft_collection_denoms, NftCollectionAddress, NftCollectionAddressTokenId,
        NftCollectionInfoByDenom, NftContractType, TokenId,
    };
    use nft_marketplace_utils::nft_offer::{nft_offers, NftOffer};
    use nft_marketplace_utils::nft_sale::{
        define_unique_collection_nft_id, nfts_for_sale, NftSale, TokenSaleHistory,
        TokensAndIfSaleInfo,
    };
    use nft_marketplace_utils::profile::Profile;
    use crate::constants::{MARKETPLACE_USDC_INDICATOR, MAX_NFT_PER_COLLECTION};
    use crate::state::{
        CONFIG, GENERAL_STATS, LISTED_NFT_COLLECTIONS_INFO_AND_USDC_VOL,
        MARKETPLACE_STATS_BY_DENOM, PROFILES, REWARD_SYSTEM, TOKEN_SALE_HISTORY,
        USERNAMES,
    };
    const MAX_OUTPUT_LENGTH: u32 = 500;
    const DEFAULT_OUTPUT_LENGTH: u32 = 20;
    pub fn query_config(deps: Deps) -> StdResult<ConfigRewardGenStatsMsg> {
        let config = CONFIG.load(deps.storage)?;
        let reward_system = REWARD_SYSTEM.load(deps.storage)?;
        let general_stats = GENERAL_STATS.load(deps.storage)?;
        Ok(ConfigRewardGenStatsMsg {
            contract_enabled: config.contract_enabled,
            contract_owner: config.contract_owner,
            accepted_ibc_denominations: config.accepted_ibc_denominations,
            marketplace_pct_fees: config.marketplace_pct_fees,
            marketplace_listing_fee_value: config.marketplace_listing_fee_value,
            marketplace_listing_fee_denom: config.marketplace_listing_fee_denom,
            oracle_contract_address: config.oracle_contract_address,
            reward_system,
            general_stats,
        })
    }
    pub fn query_nft_collection(
        deps: Deps,
        nft_collection_address: NftCollectionAddress,
    ) -> StdResult<Vec<NftCollectionInfoByDenom>> {
        let nft_collection_denoms_info = nft_collection_denoms()
            .idx
            .collection_index
            .prefix(Addr::unchecked(nft_collection_address))
            .range(deps.storage, None, None, Order::Ascending)
            .map(|std_result| std_result.map(|item| item.1))
            .collect::<StdResult<Vec<_>>>()?;
        Ok(nft_collection_denoms_info)
    }
    pub fn query_marketplace_info(
        deps: Deps,
    ) -> StdResult<Vec<MarketplaceStatsByDenom>> {
        let config: Config = CONFIG.load(deps.storage)?;
        let output_by_denom = config
            .accepted_ibc_denominations
            .list_of_denoms
            .iter()
            .map(|accepted_denom| {
                MARKETPLACE_STATS_BY_DENOM.load(deps.storage, accepted_denom)
            })
            .collect::<StdResult<Vec<MarketplaceStatsByDenom>>>()
            .unwrap_or_default();
        Ok(output_by_denom)
    }
    pub fn query_marketplace_total_volume(deps: Deps) -> StdResult<Uint128> {
        let volume: Uint128 = LISTED_NFT_COLLECTIONS_INFO_AND_USDC_VOL
            .load(deps.storage, MARKETPLACE_USDC_INDICATOR)?
            .usdc_volume;
        Ok(volume)
    }
    pub fn query_nft_collection_total_volume(
        deps: Deps,
        nft_collection_address: NftCollectionAddress,
    ) -> StdResult<Uint128> {
        let volume: Uint128 = LISTED_NFT_COLLECTIONS_INFO_AND_USDC_VOL
            .load(deps.storage, &nft_collection_address)?
            .usdc_volume;
        Ok(volume)
    }
    pub fn query_nft_collection_type(
        deps: Deps,
        nft_collection_address: NftCollectionAddress,
    ) -> StdResult<NftContractType> {
        let nft_contract_type: NftContractType = LISTED_NFT_COLLECTIONS_INFO_AND_USDC_VOL
            .load(deps.storage, &nft_collection_address)?
            .nft_contract_type;
        Ok(nft_contract_type)
    }
    pub fn query_nft_for_sale(
        deps: Deps,
        collection_address: NftCollectionAddress,
        token_id: String,
    ) -> StdResult<NftSale> {
        let collection_token_id_unique: String = define_unique_collection_nft_id(
            &collection_address,
            &token_id,
        );
        let nft_for_sale = nfts_for_sale()
            .may_load(deps.storage, collection_token_id_unique)?;
        if let Some(nft_for_sale) = nft_for_sale {
            Ok(nft_for_sale)
        } else {
            Err(StdError::generic_err("NftNotForSale"))
        }
    }
    pub fn query_nft_trade_history(
        deps: Deps,
        nft_collection_address: NftCollectionAddress,
        token_id: TokenId,
    ) -> StdResult<Vec<TokenSaleHistory>> {
        let collection_token_id_unique: String = define_unique_collection_nft_id(
            &nft_collection_address,
            &token_id,
        );
        let nft_trade_history = TOKEN_SALE_HISTORY
            .load(deps.storage, &collection_token_id_unique)?;
        Ok(nft_trade_history)
    }
    pub fn query_profile_info(
        deps: Deps,
        address_or_username: String,
    ) -> StdResult<Profile> {
        let address: String;
        let username: String;
        let profile: Profile;
        if deps.api.addr_validate(&address_or_username).is_err() {
            username = address_or_username;
            let address_result = USERNAMES.load(deps.storage, &username)?;
            address = (*address_result).parse().unwrap();
            profile = PROFILES.load(deps.storage, &address)?;
        } else {
            address = address_or_username;
            profile = PROFILES.load(deps.storage, &address)?;
        }
        Ok(profile)
    }
    pub fn query_nfts_for_sale_from_seller(
        deps: Deps,
        seller: String,
        start_after_collection_token_id: Option<NftCollectionAddressTokenId>,
        output_length: Option<u32>,
    ) -> StdResult<Vec<NftSale>> {
        let max_size = output_length
            .unwrap_or(DEFAULT_OUTPUT_LENGTH)
            .min(MAX_OUTPUT_LENGTH) as usize;
        let nfts_for_sale_info = nfts_for_sale()
            .idx
            .seller_index
            .prefix(seller)
            .range(
                deps.storage,
                Some(
                    Bound::exclusive(start_after_collection_token_id.unwrap_or_default()),
                ),
                None,
                Order::Ascending,
            )
            .take(max_size)
            .map(|std_result| std_result.map(|item| item.1))
            .collect::<StdResult<Vec<_>>>()?;
        Ok(nfts_for_sale_info)
    }
    pub fn query_all_tokens_by_coll_and_if_sale(
        deps: Deps,
        address: String,
        nft_collection_address: NftCollectionAddress,
        output_length: Option<u32>,
    ) -> StdResult<Vec<TokensAndIfSaleInfo>> {
        let max_size = output_length
            .unwrap_or(DEFAULT_OUTPUT_LENGTH)
            .min(MAX_OUTPUT_LENGTH) as usize;
        let nfts_for_sale_info = nfts_for_sale()
            .idx
            .collection_seller_index
            .prefix((nft_collection_address.clone(), address.clone()))
            .range(deps.storage, None, None, Order::Ascending)
            .take(max_size)
            .map(|std_result| std_result.map(|item| item.1))
            .collect::<StdResult<Vec<_>>>()?;
        let all_tokens: TokensResponse = deps
            .querier
            .query::<
                TokensResponse,
            >(
                &QueryRequest::Wasm(WasmQuery::Smart {
                    contract_addr: nft_collection_address,
                    msg: to_binary(
                        &Cw721QueryMsg::Tokens {
                            owner: address,
                            start_after: None,
                            limit: Some(max_size as u32),
                        },
                    )?,
                }),
            )?;
        let mut output_matched: Vec<TokensAndIfSaleInfo> = Vec::with_capacity(
            all_tokens.tokens.len(),
        );
        for token in all_tokens.tokens.iter() {
            let is_for_sale = nfts_for_sale_info
                .iter()
                .any(|nft_sale| &nft_sale.token_id == token);
            let token_and_if_sale: TokensAndIfSaleInfo = TokensAndIfSaleInfo {
                token_id: token.clone(),
                for_sale: is_for_sale,
            };
            output_matched.push(token_and_if_sale);
        }
        Ok(output_matched)
    }
    pub fn query_nft_offers_from_offerer(
        deps: Deps,
        offerer: String,
        start_after: Option<(NftCollectionAddress, TokenId)>,
        output_length: Option<u32>,
    ) -> StdResult<Vec<NftOffer>> {
        let max_size = output_length
            .unwrap_or(DEFAULT_OUTPUT_LENGTH)
            .min(MAX_OUTPUT_LENGTH) as usize;
        let mut start_after_valid: Option<Bound<String>> = None;
        if let Some((nft_collection_address, token_id)) = start_after {
            let unique_id = define_unique_collection_nft_id(
                &nft_collection_address,
                &token_id,
            );
            start_after_valid = Some(Bound::exclusive(unique_id));
        }
        let nfts_for_sale_info = nft_offers()
            .idx
            .offerer_index
            .prefix(offerer)
            .range(deps.storage, start_after_valid, None, Order::Ascending)
            .take(max_size)
            .map(|std_result| std_result.map(|item| item.1))
            .collect::<StdResult<Vec<_>>>()?;
        Ok(nfts_for_sale_info)
    }
    pub fn query_token_ids_by_collection(
        deps: Deps,
        address: String,
        nft_collection_addresses: Vec<NftCollectionAddress>,
    ) -> StdResult<Vec<(NftCollectionAddress, Vec<String>)>> {
        let mut output = Vec::with_capacity(nft_collection_addresses.len());
        for nft_coll in nft_collection_addresses.iter() {
            let tokens_response = Cw721Contract::<
                Empty,
                Empty,
            >(deps.api.addr_validate(nft_coll)?, PhantomData, PhantomData)
                .tokens(
                    &deps.querier,
                    address.clone(),
                    None,
                    Some(MAX_NFT_PER_COLLECTION),
                )?;
            output.push((nft_coll.clone(), tokens_response.tokens))
        }
        Ok(output)
    }
    pub fn query_nft_offers_by_token_id(
        deps: Deps,
        nft_collection_address: NftCollectionAddress,
        token_id: TokenId,
        start_after: Option<(NftCollectionAddress, TokenId)>,
        output_length: Option<u32>,
    ) -> StdResult<Vec<NftOffer>> {
        let max_size = output_length
            .unwrap_or(DEFAULT_OUTPUT_LENGTH)
            .min(MAX_OUTPUT_LENGTH) as usize;
        let prefix = define_unique_collection_nft_id(&nft_collection_address, &token_id);
        let mut start_after_valid: Option<Bound<String>> = None;
        if let Some((nft_collection_address, token_id)) = start_after {
            let unique_id = define_unique_collection_nft_id(
                &nft_collection_address,
                &token_id,
            );
            start_after_valid = Some(Bound::exclusive(unique_id));
        }
        let nfts_for_sale_info = nft_offers()
            .idx
            .collection_tokenid_index
            .prefix(prefix)
            .range(deps.storage, start_after_valid, None, Order::Ascending)
            .take(max_size)
            .map(|std_result| std_result.map(|item| item.1))
            .collect::<StdResult<Vec<_>>>()?;
        Ok(nfts_for_sale_info)
    }
    pub fn query_nfts_for_sale_from_collection(
        deps: Deps,
        nft_collection_address: NftCollectionAddress,
        start_after_token_id: Option<TokenId>,
        output_length: Option<u32>,
    ) -> StdResult<Vec<NftSale>> {
        let max_size = output_length
            .unwrap_or(DEFAULT_OUTPUT_LENGTH)
            .min(MAX_OUTPUT_LENGTH) as usize;
        let collection_token_id_unique: String = define_unique_collection_nft_id(
            &nft_collection_address,
            &start_after_token_id.unwrap_or_default(),
        );
        let nfts_for_sale_info = nfts_for_sale()
            .idx
            .collection_index
            .prefix(nft_collection_address)
            .range(
                deps.storage,
                Some(Bound::exclusive(collection_token_id_unique)),
                None,
                Order::Ascending,
            )
            .take(max_size)
            .map(|std_result| std_result.map(|item| item.1))
            .collect::<StdResult<Vec<_>>>()?;
        Ok(nfts_for_sale_info)
    }
}
pub mod helper_functions {
    pub mod royalties {
        use std::str::FromStr;
        use cosmwasm_std::{
            Decimal, Deps, QuerierWrapper, QueryRequest, to_binary, Uint128, WasmQuery,
        };
        use cw721::{Cw721QueryMsg, NftInfoResponse, TokensResponse};
        use cw2981_multiroyalties::msg::Cw2981QueryMsg;
        use general_utils::error::ContractError;
        use general_utils::error::NftMarketplaceError::{
            InvalidNftCollection, InvalidRoyalty,
        };
        use nft_marketplace_utils::legacy_nft_metadata::Cw2981LegacyMetadata;
        use nft_marketplace_utils::nft_collection::{
            NftCollectionInfoAndUsdcVol, NftContractType,
        };
        use nft_marketplace_utils::nft_sale::NftSale;
        use nft_marketplace_utils::response_handler::RoyaltiesInfoResponse;
        use crate::constants::MADHUAHUA_NFTS;
        pub fn validate_contract_type_and_royalty(
            nft_collection_info: NftCollectionInfoAndUsdcVol,
            querier: QuerierWrapper,
        ) -> Result<(), ContractError> {
            match nft_collection_info.nft_contract_type {
                NftContractType::Cw2981MultiRoyalties => {
                    let nft_tokens: TokensResponse = querier
                        .query::<
                            TokensResponse,
                        >(
                            &QueryRequest::Wasm(WasmQuery::Smart {
                                contract_addr: nft_collection_info
                                    .nft_collection_address
                                    .clone(),
                                msg: to_binary(
                                    &Cw721QueryMsg::AllTokens {
                                        start_after: None,
                                        limit: Some(1),
                                    },
                                )?,
                            }),
                        )?;
                    let _nft_royalties: Vec<RoyaltiesInfoResponse> = querier
                        .query::<
                            Vec<RoyaltiesInfoResponse>,
                        >(
                            &QueryRequest::Wasm(WasmQuery::Smart {
                                contract_addr: nft_collection_info.nft_collection_address,
                                msg: to_binary(
                                    &cw2981_multiroyalties::QueryMsg::Extension {
                                        msg: Cw2981QueryMsg::RoyaltyInfo {
                                            token_id: nft_tokens.tokens[0].clone(),
                                            sale_price: Uint128::new(100_000u128),
                                        },
                                    },
                                )?,
                            }),
                        )?;
                }
                NftContractType::Cw2981MadHuahua => {
                    if nft_collection_info.nft_collection_address != MADHUAHUA_NFTS {
                        return Err(
                            ContractError::NftMarketplaceError(InvalidNftCollection {}),
                        );
                    }
                }
                NftContractType::Cw721OnChainMetadata => {
                    let nft_tokens: TokensResponse = querier
                        .query::<
                            TokensResponse,
                        >(
                            &QueryRequest::Wasm(WasmQuery::Smart {
                                contract_addr: nft_collection_info
                                    .nft_collection_address
                                    .clone(),
                                msg: to_binary(
                                    &Cw721QueryMsg::AllTokens {
                                        start_after: None,
                                        limit: Some(1),
                                    },
                                )?,
                            }),
                        )?;
                    let nft_info: NftInfoResponse<cw721_metadata_onchain::Extension> = querier
                        .query::<
                            NftInfoResponse<cw721_metadata_onchain::Extension>,
                        >(
                            &QueryRequest::Wasm(WasmQuery::Smart {
                                contract_addr: nft_collection_info.nft_collection_address,
                                msg: to_binary(
                                    &cw721_metadata_onchain::QueryMsg::NftInfo {
                                        token_id: nft_tokens.tokens[0].clone(),
                                    },
                                )?,
                            }),
                        )?;
                    if nft_info.token_uri.is_some() || nft_info.extension.is_none() {
                        return Err(
                            ContractError::NftMarketplaceError(InvalidNftCollection {}),
                        );
                    }
                }
                NftContractType::MarketplaceInfo => {
                    return Err(ContractError::NftMarketplaceError(InvalidNftCollection {}));
                }
            }
            Ok(())
        }
        pub fn compute_royalty(
            nft_for_sale_info: NftSale,
            nft_collection_info: NftCollectionInfoAndUsdcVol,
            deps: Deps,
        ) -> Result<Vec<RoyaltiesInfoResponse>, ContractError> {
            let mut nft_royalties: Vec<RoyaltiesInfoResponse> = ::alloc::vec::Vec::new();
            match nft_collection_info.nft_contract_type {
                NftContractType::Cw2981MultiRoyalties => {
                    nft_royalties = deps
                        .querier
                        .query::<
                            Vec<RoyaltiesInfoResponse>,
                        >(
                            &QueryRequest::Wasm(WasmQuery::Smart {
                                contract_addr: nft_for_sale_info
                                    .nft_collection_address
                                    .clone(),
                                msg: to_binary(
                                    &cw2981_multiroyalties::QueryMsg::Extension {
                                        msg: Cw2981QueryMsg::RoyaltyInfo {
                                            token_id: nft_for_sale_info.token_id.clone(),
                                            sale_price: nft_for_sale_info.sale_price_value,
                                        },
                                    },
                                )?,
                            }),
                        )?;
                }
                NftContractType::Cw2981MadHuahua => {
                    let nft_metadata_for_royalties: cw721::NftInfoResponse<
                        Cw2981LegacyMetadata,
                    > = deps
                        .querier
                        .query::<
                            cw721::NftInfoResponse<Cw2981LegacyMetadata>,
                        >(
                            &QueryRequest::Wasm(WasmQuery::Smart {
                                contract_addr: nft_for_sale_info
                                    .nft_collection_address
                                    .clone(),
                                msg: to_binary(
                                    &cw721::Cw721QueryMsg::NftInfo {
                                        token_id: nft_for_sale_info.token_id,
                                    },
                                )?,
                            }),
                        )?;
                    for royalty in nft_metadata_for_royalties
                        .extension
                        .royalty_info
                        .unwrap()
                        .into_iter()
                    {
                        if Decimal::permille(
                            royalty.thousands.clone().parse::<u64>().unwrap(),
                        ) > Decimal::from_str("1.0").unwrap()
                            || Decimal::permille(
                                royalty.thousands.clone().parse::<u64>().unwrap(),
                            ) < Decimal::from_str("0.001").unwrap()
                        {
                            return Err(ContractError::NftMarketplaceError(InvalidRoyalty {}));
                        }
                        let royalty_amount: Uint128 = nft_for_sale_info.sale_price_value
                            * Decimal::permille(
                                royalty.thousands.clone().parse::<u64>().unwrap(),
                            );
                        nft_royalties
                            .push(RoyaltiesInfoResponse {
                                address: deps
                                    .api
                                    .addr_validate(&royalty.address.to_string())?,
                                royalty_amount,
                            })
                    }
                }
                _ => {}
            }
            Ok(nft_royalties)
        }
    }
}
pub mod state {
    use cw_storage_plus::{Item, Map};
    use nft_marketplace_utils::config::Config;
    use nft_marketplace_utils::marketplace_statistics::{
        GeneralStats, MarketplaceStatsByDenom,
    };
    use nft_marketplace_utils::nft_collection::NftCollectionInfoAndUsdcVol;
    use nft_marketplace_utils::nft_sale::TokenSaleHistory;
    use nft_marketplace_utils::profile::Profile;
    use nft_marketplace_utils::reward_system::RewardSystem;
    pub const CONFIG: Item<Config> = Item::new("config");
    pub const REWARD_SYSTEM: Item<RewardSystem> = Item::new("reward_system");
    pub const MARKETPLACE_STATS_BY_DENOM: Map<&str, MarketplaceStatsByDenom> = Map::new(
        "marketplace_stats_by_denom",
    );
    pub const LISTED_NFT_COLLECTIONS_INFO_AND_USDC_VOL: Map<
        &str,
        NftCollectionInfoAndUsdcVol,
    > = Map::new("listed_nft_collections_info_and_usdc_vol");
    pub const TOKEN_SALE_HISTORY: Map<&str, Vec<TokenSaleHistory>> = Map::new(
        "token_sale_history",
    );
    pub const PROFILES: Map<&str, Profile> = Map::new("profiles");
    pub const USERNAMES: Map<&str, String> = Map::new("usernames");
    pub const GENERAL_STATS: Item<GeneralStats> = Item::new("general_stats");
}
pub mod tests {
    pub mod utils_common {}
    pub mod utils_marketplace_contract_test {}
    pub mod utils_nft_contract_test {}
    pub mod utils_price_oracle_contract_test {}
    pub mod instantiate {}
    pub mod constants {
        pub const OWNER: &str = "chihuahua1ifxixonpu9laitc4w6f17m2jfin3hchp4n85ov";
        pub const FEEDER: &str = "chihuahua15xlwzvtblxvx9gem11p1pkotq1xo2a5452vf5d";
        pub const WALLET2: &str = "chihuahua1yk8khat1cmofok9yxnt6q06aueocv3pc8f32jo";
        pub const WALLET3: &str = "chihuahua1sdn8tr8d86boe49ifuk11ibsuncpnp8fx6u9tn";
        pub const WALLET4: &str = "chihuahua1m8dlu9gd9ztamqehba0r7trfse6fs6k9nrzyx8";
        pub const WALLET5: &str = "chihuahua128g3f8bp24mj4p9nqm9kqdo1urufo5wkqf65t3";
        pub const ROYALTY_RECEIVER1: &str = "chihuahua1l6pm0qgul73h5m943moxfwf1mx534wjtqsi7y9";
        pub const ROYALTY_RECEIVER2: &str = "chihuahua1gm6afmyfhldd2eentuskw3h0rq296nlt92vmxz";
    }
    pub mod update_config {}
    pub mod add_new_collection {}
    pub mod new_cancel_update_sale {}
    pub mod buy {}
    pub mod profile_create_update_upgrade_send_msg {}
    pub mod stats_states_behaviours {}
    pub mod offer {}
    pub mod cw721_no_royalty_collection {}
}
